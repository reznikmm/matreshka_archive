<?xml version="1.0" encoding="UTF-8"?>
<!-- This is merged by hand model to bootstrap CMOF library. It is based on
     LM.cmof model, and adds:
       - Package::uri
       - Tag (note, Tag is not inherited from Element)
       - Type:isInstance not supported
-->
<xmi:XMI xmi:version="2.1" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:cmof="http://schema.omg.org/spec/MOF/2.0/cmof.xml">
  <cmof:Package xmi:id="_0" name="CMOF" uri="http://schema.omg.org/spec/MOF/2.0/cmof.xml">
    <packagedElement xmi:type="cmof:PrimitiveType" xmi:id="Integer" name="Integer">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Integer-_ownedComment.0" annotatedElement="Integer">
        <body>An integer is a primitive type representing integer values.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:PrimitiveType" xmi:id="Boolean" name="Boolean">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Boolean-_ownedComment.0" annotatedElement="Boolean">
        <body>A Boolean type is used for logical expression, consisting of the predefined values true and false.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:PrimitiveType" xmi:id="String" name="String">
      <ownedComment xmi:type="cmof:Comment" xmi:id="String-_ownedComment.0" annotatedElement="String">
        <body>A string is a sequence of characters in some suitable character set used to display information about the model. Character sets may include non-Roman alphabets and characters.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:PrimitiveType" xmi:id="UnlimitedNatural" name="UnlimitedNatural">
      <ownedComment xmi:type="cmof:Comment" xmi:id="UnlimitedNatural-_ownedComment.0" annotatedElement="UnlimitedNatural">
        <body>An unlimited natural is a primitive type representing unlimited natural values.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Classifier" name="Classifier" isAbstract="true" superClass="Namespace Type">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-_ownedComment.0" annotatedElement="Classifier">
        <body>A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-no_cycles_in_generalization" name="no_cycles_in_generalization" constrainedElement="Classifier" namespace="Classifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-no_cycles_in_generalization-_ownedComment.0" annotatedElement="Classifier-no_cycles_in_generalization">
          <body>Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-no_cycles_in_generalization-_specification">
          <language>OCL</language>
          <body>not self.allParents()->includes(self)</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-specialize_type" name="specialize_type" constrainedElement="Classifier" namespace="Classifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-specialize_type-_ownedComment.0" annotatedElement="Classifier-specialize_type">
          <body>A classifier may only specialize classifiers of a valid type.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-specialize_type-_specification">
          <language>OCL</language>
          <body>self.parents()->forAll(c | self.maySpecializeType(c))</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-attribute" name="attribute" type="Property" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Classifier-feature" association="A_attribute_classifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-attribute-_ownedComment.0" annotatedElement="Classifier-attribute">
          <body>Refers to all of the Properties that are direct (i.e. not inherited or imported) attributes of the classifier.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-feature" name="feature" type="Feature" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Namespace-member" association="A_feature_featuringClassifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-feature-_ownedComment.0" annotatedElement="Classifier-feature">
          <body>Note that there may be members of the Classifier that are of the type Feature but are not included in this association, e.g. inherited features.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-general" name="general" type="Classifier" upper="*" lower="0" association="A_general_classifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-general-_ownedComment.0" annotatedElement="Classifier-general">
          <body>References the general classifier in the Generalization relationship.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-inheritedMember" name="inheritedMember" type="NamedElement" upper="*" lower="0" isReadOnly="true" isDerived="true" subsettedProperty="Namespace-member" association="A_inheritedMember_classifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inheritedMember-_ownedComment.0" annotatedElement="Classifier-inheritedMember">
          <body>Specifies all elements inherited by this classifier from the general classifiers.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-isFinalSpecialization" name="isFinalSpecialization" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-isFinalSpecialization-_ownedComment.0" annotatedElement="Classifier-isFinalSpecialization">
          <body>If true, the Classifier cannot be specialized by generalization. Note that this property is preserved through package merge operations; that is, the capability to specialize a Classifier (i.e., isFinalSpecialization =false) must be preserved in the resulting Classifier of a package merge operation where a Classifier with isFinalSpecialization =false is merged with a matching Classifier with isFinalSpecialization =true: the resulting Classifier will have isFinalSpecialization =false.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-conformsTo" name="conformsTo" class="Classifier" isQuery="true" redefinedOperation="Type-conformsTo" bodyCondition="Classifier-conformsTo-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-conformsTo-_ownedComment.0" annotatedElement="Classifier-conformsTo">
          <body>The query conformsTo() gives true for a classifier that defines a type that conforms to another. This is used, for example, in the specification of signature conformance for operations.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-conformsTo-spec" name="spec" constrainedElement="Classifier-conformsTo" namespace="Classifier-conformsTo">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-conformsTo-spec-_specification">
            <language>OCL</language>
            <body>result = (self=other) or (self.allParents()->includes(other))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-conformsTo-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-conformsTo-other" name="other" type="Classifier"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-allFeatures" name="allFeatures" class="Classifier" isQuery="true" bodyCondition="Classifier-allFeatures-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-allFeatures-_ownedComment.0" annotatedElement="Classifier-allFeatures">
          <body>The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-allFeatures-spec" name="spec" constrainedElement="Classifier-allFeatures" namespace="Classifier-allFeatures">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-allFeatures-spec-_specification">
            <language>OCL</language>
            <body>result = member->select(oclIsKindOf(Feature))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-allFeatures-_ownedParameter.0" type="Feature" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-general.1" name="general" class="Classifier" isQuery="true" bodyCondition="Classifier-general.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-general.1-_ownedComment.0" annotatedElement="Classifier-general.1">
          <body>The general classifiers are the classifiers referenced by the generalization relationships.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-general.1-spec" name="spec" constrainedElement="Classifier-general.1 Classifier-general" namespace="Classifier-general.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-general.1-spec-_specification">
            <language>OCL</language>
            <body>result = self.parents()</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-general.1-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-parents" name="parents" class="Classifier" isQuery="true" bodyCondition="Classifier-parents-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-parents-_ownedComment.0" annotatedElement="Classifier-parents">
          <body>The query parents() gives all of the immediate ancestors of a generalized Classifier.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-parents-spec" name="spec" constrainedElement="Classifier-parents" namespace="Classifier-parents">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-parents-spec-_specification">
            <language>OCL</language>
            <body>result = generalization.general</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-parents-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-inheritedMember.1" name="inheritedMember" class="Classifier" isQuery="true" bodyCondition="Classifier-inheritedMember.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inheritedMember.1-_ownedComment.0" annotatedElement="Classifier-inheritedMember.1">
          <body>The inheritedMember association is derived by inheriting the inheritable members of the parents.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inheritedMember.1-spec" name="spec" constrainedElement="Classifier-inheritedMember.1 Classifier-inheritedMember" namespace="Classifier-inheritedMember.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inheritedMember.1-spec-_specification">
            <language>OCL</language>
            <body>result = self.inherit(self.parents()->collect(p | p.inheritableMembers(self))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inheritedMember.1-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-allParents" name="allParents" class="Classifier" isQuery="true" bodyCondition="Classifier-allParents-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-allParents-_ownedComment.0" annotatedElement="Classifier-allParents">
          <body>The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-allParents-spec" name="spec" constrainedElement="Classifier-allParents" namespace="Classifier-allParents">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-allParents-spec-_specification">
            <language>OCL</language>
            <body>result = self.parents()->union(self.parents()->collect(p | p.allParents())</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-allParents-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-inheritableMembers" name="inheritableMembers" class="Classifier" isQuery="true" precondition="Classifier-inheritableMembers-_ownedRule.0" bodyCondition="Classifier-inheritableMembers-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inheritableMembers-_ownedComment.0" annotatedElement="Classifier-inheritableMembers">
          <body>The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inheritableMembers-_ownedRule.0" constrainedElement="Classifier-inheritableMembers" namespace="Classifier-inheritableMembers">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inheritableMembers-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>c.allParents()->includes(self)</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inheritableMembers-spec" name="spec" constrainedElement="Classifier-inheritableMembers" namespace="Classifier-inheritableMembers">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inheritableMembers-spec-_specification">
            <language>OCL</language>
            <body>result = member->select(m | c.hasVisibilityOf(m))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inheritableMembers-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inheritableMembers-c" name="c" type="Classifier"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-hasVisibilityOf" name="hasVisibilityOf" class="Classifier" isQuery="true" precondition="Classifier-hasVisibilityOf-_ownedRule.0" bodyCondition="Classifier-hasVisibilityOf-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-hasVisibilityOf-_ownedComment.0" annotatedElement="Classifier-hasVisibilityOf">
          <body>The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is only called when the argument is something owned by a parent.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-hasVisibilityOf-_ownedRule.0" constrainedElement="Classifier-hasVisibilityOf" namespace="Classifier-hasVisibilityOf">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-hasVisibilityOf-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>self.allParents()->collect(c | c.member)->includes(n)</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-hasVisibilityOf-spec" name="spec" constrainedElement="Classifier-hasVisibilityOf" namespace="Classifier-hasVisibilityOf">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-hasVisibilityOf-spec-_specification">
            <language>OCL</language>
            <body>result = if (self.inheritedMember->includes(n)) then (n.visibility &lt;> #private) else true</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-hasVisibilityOf-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-hasVisibilityOf-n" name="n" type="NamedElement"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-inherit" name="inherit" class="Classifier" isQuery="true" bodyCondition="Classifier-inherit-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inherit-_ownedComment.0" annotatedElement="Classifier-inherit">
          <body>The inherit operation is overridden to exclude redefined properties.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inherit-spec" name="spec" constrainedElement="Classifier-inherit" namespace="Classifier-inherit">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inherit-spec-_specification">
            <language>OCL</language>
            <body>result = inhs</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inherit-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inherit-inhs" name="inhs" type="NamedElement" upper="*" lower="0"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-maySpecializeType" name="maySpecializeType" class="Classifier" isQuery="true" bodyCondition="Classifier-maySpecializeType-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-maySpecializeType-_ownedComment.0" annotatedElement="Classifier-maySpecializeType">
          <body>The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-maySpecializeType-spec" name="spec" constrainedElement="Classifier-maySpecializeType" namespace="Classifier-maySpecializeType">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-maySpecializeType-spec-_specification">
            <language>OCL</language>
            <body>result = self.oclIsKindOf(c.oclType)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-maySpecializeType-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-maySpecializeType-c" name="c" type="Classifier"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="DirectedRelationship" name="DirectedRelationship" isAbstract="true" superClass="Relationship">
      <ownedComment xmi:type="cmof:Comment" xmi:id="DirectedRelationship-_ownedComment.0" annotatedElement="DirectedRelationship">
        <body>A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="DirectedRelationship-source" name="source" type="Element" upper="*" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Relationship-relatedElement" association="A_source_directedRelationship">
        <ownedComment xmi:type="cmof:Comment" xmi:id="DirectedRelationship-source-_ownedComment.0" annotatedElement="DirectedRelationship-source">
          <body>Specifies the sources of the DirectedRelationship.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="DirectedRelationship-target" name="target" type="Element" upper="*" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Relationship-relatedElement" association="A_target_directedRelationship">
        <ownedComment xmi:type="cmof:Comment" xmi:id="DirectedRelationship-target-_ownedComment.0" annotatedElement="DirectedRelationship-target">
          <body>Specifies the targets of the DirectedRelationship.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Element" name="Element" isAbstract="true">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Element-_ownedComment.0" annotatedElement="Element">
        <body>An element is a constituent of a model. As such, it has the capability of owning other elements.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Element-not_own_self" name="not_own_self" constrainedElement="Element" namespace="Element">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-not_own_self-_ownedComment.0" annotatedElement="Element-not_own_self">
          <body>An element may not directly or indirectly own itself.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-not_own_self-_specification">
          <language>OCL</language>
          <body>not self.allOwnedElements()->includes(self)</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Element-has_owner" name="has_owner" constrainedElement="Element" namespace="Element">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-has_owner-_ownedComment.0" annotatedElement="Element-has_owner">
          <body>Elements that must be owned must have an owner.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-has_owner-_specification">
          <language>OCL</language>
          <body>self.mustBeOwned() implies owner->notEmpty()</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Element-ownedElement" name="ownedElement" type="Element" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" isComposite="true" association="A_ownedElement_owner">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-ownedElement-_ownedComment.0" annotatedElement="Element-ownedElement">
          <body>The Elements owned by this element.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Element-owner" name="owner" type="Element" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_ownedElement_owner">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-owner-_ownedComment.0" annotatedElement="Element-owner">
          <body>The Element that owns this element.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Element-ownedComment" name="ownedComment" type="Comment" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_ownedComment_owningElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-ownedComment-_ownedComment.0" annotatedElement="Element-ownedComment">
          <body>The Comments owned by this element.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Element-allOwnedElements" name="allOwnedElements" class="Element" isQuery="true" bodyCondition="Element-allOwnedElements-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-allOwnedElements-_ownedComment.0" annotatedElement="Element-allOwnedElements">
          <body>The query allOwnedElements() gives all of the direct and indirect owned elements of an element.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Element-allOwnedElements-spec" name="spec" constrainedElement="Element-allOwnedElements" namespace="Element-allOwnedElements">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-allOwnedElements-spec-_specification">
            <language>OCL</language>
            <body>result = ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Element-allOwnedElements-_ownedParameter.0" type="Element" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Element-mustBeOwned" name="mustBeOwned" class="Element" isQuery="true" bodyCondition="Element-mustBeOwned-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Element-mustBeOwned-_ownedComment.0" annotatedElement="Element-mustBeOwned">
          <body>The query mustBeOwned() indicates whether elements of this type must have an owner. Subclasses of Element that do not require an owner must override this operation.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Element-mustBeOwned-spec" name="spec" constrainedElement="Element-mustBeOwned" namespace="Element-mustBeOwned">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-mustBeOwned-spec-_specification">
            <language>OCL</language>
            <body>result = true</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Element-mustBeOwned-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Feature" name="Feature" isAbstract="true" superClass="RedefinableElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Feature-_ownedComment.0" annotatedElement="Feature">
        <body>A feature declares a behavioral or structural characteristic of instances of classifiers.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Feature-featuringClassifier" name="featuringClassifier" type="Classifier" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_feature_featuringClassifier">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Feature-featuringClassifier-_ownedComment.0" annotatedElement="Feature-featuringClassifier">
          <body>The Classifiers that have this Feature as a feature.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="MultiplicityElement" name="MultiplicityElement" isAbstract="true" superClass="Element">
      <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-_ownedComment.0" annotatedElement="MultiplicityElement">
        <body>A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-upper_ge_lower" name="upper_ge_lower" constrainedElement="MultiplicityElement" namespace="MultiplicityElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upper_ge_lower-_ownedComment.0" annotatedElement="MultiplicityElement-upper_ge_lower">
          <body>The upper bound must be greater than or equal to the lower bound.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-upper_ge_lower-_specification">
          <language>OCL</language>
          <body>(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-lower_ge_0" name="lower_ge_0" constrainedElement="MultiplicityElement" namespace="MultiplicityElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-lower_ge_0-_ownedComment.0" annotatedElement="MultiplicityElement-lower_ge_0">
          <body>The lower bound must be a non-negative integer literal.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-lower_ge_0-_specification">
          <language>OCL</language>
          <body>lowerBound()->notEmpty() implies lowerBound() >= 0</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-isOrdered" name="isOrdered" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-isOrdered-_ownedComment.0" annotatedElement="MultiplicityElement-isOrdered">
          <body>For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this element are sequentially ordered.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-isUnique" name="isUnique" type="Boolean" default="true">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-isUnique-_ownedComment.0" annotatedElement="MultiplicityElement-isUnique">
          <body>For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of this element are unique.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-lower" name="lower" type="Integer" lower="0" default="1">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-lower-_ownedComment.0" annotatedElement="MultiplicityElement-lower">
          <body>Specifies the lower bound of the multiplicity interval.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-upper" name="upper" type="UnlimitedNatural" lower="0" default="1">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upper-_ownedComment.0" annotatedElement="MultiplicityElement-upper">
          <body>Specifies the upper bound of the multiplicity interval.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-isMultivalued" name="isMultivalued" class="MultiplicityElement" isQuery="true" precondition="MultiplicityElement-isMultivalued-_ownedRule.0" bodyCondition="MultiplicityElement-isMultivalued-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-isMultivalued-_ownedComment.0" annotatedElement="MultiplicityElement-isMultivalued">
          <body>The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-isMultivalued-_ownedRule.0" constrainedElement="MultiplicityElement-isMultivalued" namespace="MultiplicityElement-isMultivalued">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-isMultivalued-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>upperBound()->notEmpty()</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-isMultivalued-spec" name="spec" constrainedElement="MultiplicityElement-isMultivalued" namespace="MultiplicityElement-isMultivalued">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-isMultivalued-spec-_specification">
            <language>OCL</language>
            <body>result = upperBound() > 1</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-isMultivalued-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-includesMultiplicity" name="includesMultiplicity" class="MultiplicityElement" isQuery="true" precondition="MultiplicityElement-includesMultiplicity-_ownedRule.0" bodyCondition="MultiplicityElement-includesMultiplicity-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-includesMultiplicity-_ownedComment.0" annotatedElement="MultiplicityElement-includesMultiplicity">
          <body>The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the specified multiplicity.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesMultiplicity-_ownedRule.0" constrainedElement="MultiplicityElement-includesMultiplicity" namespace="MultiplicityElement-includesMultiplicity">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesMultiplicity-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>self.upperBound()->notEmpty() and self.lowerBound()->notEmpty() and M.upperBound()->notEmpty() and M.lowerBound()->notEmpty()</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesMultiplicity-spec" name="spec" constrainedElement="MultiplicityElement-includesMultiplicity" namespace="MultiplicityElement-includesMultiplicity">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesMultiplicity-spec-_specification">
            <language>OCL</language>
            <body>result = (self.lowerBound() &lt;= M.lowerBound()) and (self.upperBound() >= M.upperBound())</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesMultiplicity-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesMultiplicity-M" name="M" type="MultiplicityElement"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-includesCardinality" name="includesCardinality" class="MultiplicityElement" isQuery="true" precondition="MultiplicityElement-includesCardinality-_ownedRule.0" bodyCondition="MultiplicityElement-includesCardinality-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-includesCardinality-_ownedComment.0" annotatedElement="MultiplicityElement-includesCardinality">
          <body>The query includesCardinality() checks whether the specified cardinality is valid for this multiplicity.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesCardinality-_ownedRule.0" constrainedElement="MultiplicityElement-includesCardinality" namespace="MultiplicityElement-includesCardinality">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesCardinality-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>upperBound()->notEmpty() and lowerBound()->notEmpty()</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesCardinality-spec" name="spec" constrainedElement="MultiplicityElement-includesCardinality" namespace="MultiplicityElement-includesCardinality">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesCardinality-spec-_specification">
            <language>OCL</language>
            <body>result = (lowerBound() &lt;= C) and (upperBound() >= C)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesCardinality-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesCardinality-C" name="C" type="Integer"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-lowerBound" name="lowerBound" class="MultiplicityElement" isQuery="true" bodyCondition="MultiplicityElement-lowerBound-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-lowerBound-_ownedComment.0" annotatedElement="MultiplicityElement-lowerBound">
          <body>The query lowerBound() returns the lower bound of the multiplicity as an integer.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-lowerBound-spec" name="spec" constrainedElement="MultiplicityElement-lowerBound" namespace="MultiplicityElement-lowerBound">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-lowerBound-spec-_specification">
            <language>OCL</language>
            <body>result = if lower->notEmpty() then lower else 1 endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-lowerBound-_ownedParameter.0" type="Integer" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-upperBound" name="upperBound" class="MultiplicityElement" isQuery="true" bodyCondition="MultiplicityElement-upperBound-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upperBound-_ownedComment.0" annotatedElement="MultiplicityElement-upperBound">
          <body>The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-upperBound-spec" name="spec" constrainedElement="MultiplicityElement-upperBound" namespace="MultiplicityElement-upperBound">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-upperBound-spec-_specification">
            <language>OCL</language>
            <body>result = if upper->notEmpty() then upper else 1 endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-upperBound-_ownedParameter.0" type="UnlimitedNatural" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Namespace" name="Namespace" isAbstract="true" superClass="NamedElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-_ownedComment.0" annotatedElement="Namespace">
        <body>A namespace is an element in a model that contains a set of named elements that can be identified by name.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-members_distinguishable" name="members_distinguishable" constrainedElement="Namespace" namespace="Namespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-members_distinguishable-_ownedComment.0" annotatedElement="Namespace-members_distinguishable">
          <body>All the members of a Namespace are distinguishable within it.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-members_distinguishable-_specification">
          <language>OCL</language>
          <body>membersAreDistinguishable()</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-importedMember" name="importedMember" type="PackageableElement" upper="*" lower="0" isReadOnly="true" isDerived="true" subsettedProperty="Namespace-member" association="A_importedMember_namespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-importedMember-_ownedComment.0" annotatedElement="Namespace-importedMember">
          <body>References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-elementImport" name="elementImport" type="ElementImport" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_elementImport_importingNamespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-elementImport-_ownedComment.0" annotatedElement="Namespace-elementImport">
          <body>References the ElementImports owned by the Namespace.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-packageImport" name="packageImport" type="PackageImport" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_packageImport_importingNamespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-packageImport-_ownedComment.0" annotatedElement="Namespace-packageImport">
          <body>References the PackageImports owned by the Namespace.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-ownedMember" name="ownedMember" type="NamedElement" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" isComposite="true" subsettedProperty="Namespace-member Element-ownedElement" association="A_ownedMember_namespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-ownedMember-_ownedComment.0" annotatedElement="Namespace-ownedMember">
          <body>A collection of NamedElements owned by the Namespace.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-member" name="member" type="NamedElement" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_member_namespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-member-_ownedComment.0" annotatedElement="Namespace-member">
          <body>A collection of NamedElements identifiable within the Namespace, either by being owned or by being introduced by importing or inheritance.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-ownedRule" name="ownedRule" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_ownedRule_context"/>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-importedMember.1" name="importedMember" class="Namespace" isQuery="true" bodyCondition="Namespace-importedMember.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-importedMember.1-_ownedComment.0" annotatedElement="Namespace-importedMember.1">
          <body>The importedMember property is derived from the ElementImports and the PackageImports. References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-importedMember.1-spec" name="spec" constrainedElement="Namespace-importedMember.1 Namespace-importedMember" namespace="Namespace-importedMember.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-importedMember.1-spec-_specification">
            <language>OCL</language>
            <body>result = self.importMembers(self.elementImport.importedElement.asSet()->union(self.packageImport.importedPackage->collect(p | p.visibleMembers())))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-importedMember.1-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-getNamesOfMember" name="getNamesOfMember" class="Namespace" isQuery="true" bodyCondition="Namespace-getNamesOfMember-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-getNamesOfMember-_ownedComment.0" annotatedElement="Namespace-getNamesOfMember">
          <body>The query getNamesOfMember() takes importing into account. It gives back the set of names that an element would have in an importing namespace, either because it is owned, or if not owned then imported individually, or if not individually then from a package.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-getNamesOfMember-spec" name="spec" constrainedElement="Namespace-getNamesOfMember" namespace="Namespace-getNamesOfMember">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-getNamesOfMember-spec-_specification">
            <language>OCL</language>
            <body>result = if self.ownedMember->includes(element)&#xA;then Set{}->include(element.name)&#xA;else let elementImports: ElementImport = self.elementImport->select(ei | ei.importedElement = element) in&#xA;  if elementImports->notEmpty()&#xA;  then elementImports->collect(el | el.getName())&#xA;  else self.packageImport->select(pi | pi.importedPackage.visibleMembers()->includes(element))->collect(pi | pi.importedPackage.getNamesOfMember(element))&#xA;  endif&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-getNamesOfMember-_ownedParameter.0" type="String" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-getNamesOfMember-element" name="element" type="NamedElement"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-importMembers" name="importMembers" class="Namespace" isQuery="true" bodyCondition="Namespace-importMembers-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-importMembers-_ownedComment.0" annotatedElement="Namespace-importMembers">
          <body>The query importMembers() defines which of a set of PackageableElements are actually imported into the namespace. This excludes hidden ones, i.e., those which have names that conflict with names of owned members, and also excludes elements which would have the same name when imported.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-importMembers-spec" name="spec" constrainedElement="Namespace-importMembers" namespace="Namespace-importMembers">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-importMembers-spec-_specification">
            <language>OCL</language>
            <body>result = self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | mem.imp.isDistinguishableFrom(mem, self)))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-importMembers-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-importMembers-imps" name="imps" type="PackageableElement" upper="*" lower="0"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-excludeCollisions" name="excludeCollisions" class="Namespace" isQuery="true" bodyCondition="Namespace-excludeCollisions-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-excludeCollisions-_ownedComment.0" annotatedElement="Namespace-excludeCollisions">
          <body>The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this namespace.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-excludeCollisions-spec" name="spec" constrainedElement="Namespace-excludeCollisions" namespace="Namespace-excludeCollisions">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-excludeCollisions-spec-_specification">
            <language>OCL</language>
            <body>result = imps->reject(imp1 | imps.exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-excludeCollisions-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-excludeCollisions-imps" name="imps" type="PackageableElement" upper="*" lower="0"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-membersAreDistinguishable" name="membersAreDistinguishable" class="Namespace" isQuery="true" bodyCondition="Namespace-membersAreDistinguishable-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-membersAreDistinguishable-_ownedComment.0" annotatedElement="Namespace-membersAreDistinguishable">
          <body>The Boolean query membersAreDistinguishable() determines whether all of the namespace's members are distinguishable within it.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-membersAreDistinguishable-spec" name="spec" constrainedElement="Namespace-membersAreDistinguishable" namespace="Namespace-membersAreDistinguishable">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-membersAreDistinguishable-spec-_specification">
            <language>OCL</language>
            <body>result = self.member->forAll( memb |&#xA;&#x9;self.member->excluding(memb)->forAll(other |&#xA;&#x9;&#x9;memb.isDistinguishableFrom(other, self)))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-membersAreDistinguishable-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="PackageableElement" name="PackageableElement" isAbstract="true" superClass="NamedElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="PackageableElement-_ownedComment.0" annotatedElement="PackageableElement">
        <body>A packageable element indicates a named element that may be owned directly by a package.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="RedefinableElement" name="RedefinableElement" isAbstract="true" superClass="NamedElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-_ownedComment.0" annotatedElement="RedefinableElement">
        <body>A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-redefinition_context_valid" name="redefinition_context_valid" constrainedElement="RedefinableElement" namespace="RedefinableElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinition_context_valid-_ownedComment.0" annotatedElement="RedefinableElement-redefinition_context_valid">
          <body>At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-redefinition_context_valid-_specification">
          <language>OCL</language>
          <body>self.redefinedElement->forAll(e | self.isRedefinitionContextValid(e))</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-redefinition_consistent" name="redefinition_consistent" constrainedElement="RedefinableElement" namespace="RedefinableElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinition_consistent-_ownedComment.0" annotatedElement="RedefinableElement-redefinition_consistent">
          <body>A redefining element must be consistent with each redefined element.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-redefinition_consistent-_specification">
          <language>OCL</language>
          <body>self.redefinedElement->forAll(re | re.isConsistentWith(self))</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-non_leaf_redefinition" name="non_leaf_redefinition" constrainedElement="RedefinableElement" namespace="RedefinableElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-non_leaf_redefinition-_ownedComment.0" annotatedElement="RedefinableElement-non_leaf_redefinition">
          <body>A redefinable element can only redefine non-leaf redefinable elements</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-non_leaf_redefinition-_specification">
          <language>OCL</language>
          <body>self.redefinedElement->forAll(not isLeaf)</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="RedefinableElement-redefinitionContext" name="redefinitionContext" type="Classifier" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_redefinitionContext_redefinableElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinitionContext-_ownedComment.0" annotatedElement="RedefinableElement-redefinitionContext">
          <body>References the contexts that this element may be redefined from.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="RedefinableElement-redefinedElement" name="redefinedElement" type="RedefinableElement" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_redefinedElement_redefinableElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinedElement-_ownedComment.0" annotatedElement="RedefinableElement-redefinedElement">
          <body>The redefinable element that is being redefined by this element.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="RedefinableElement-isLeaf" name="isLeaf" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-isLeaf-_ownedComment.0" annotatedElement="RedefinableElement-isLeaf">
          <body>Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not possible to further redefine the RedefinableElement. Note that this property is preserved through package merge operations; that is, the capability to redefine a RedefinableElement (i.e., isLeaf=false) must be preserved in the resulting RedefinableElement of a package merge operation where a RedefinableElement with isLeaf=false is merged with a matching RedefinableElement with isLeaf=true: the resulting RedefinableElement will have isLeaf=false. Default value is false.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="RedefinableElement-isConsistentWith" name="isConsistentWith" class="RedefinableElement" isQuery="true" precondition="RedefinableElement-isConsistentWith-_ownedRule.1" bodyCondition="RedefinableElement-isConsistentWith-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-isConsistentWith-_ownedComment.0" annotatedElement="RedefinableElement-isConsistentWith">
          <body>The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-isConsistentWith-spec" name="spec" constrainedElement="RedefinableElement-isConsistentWith" namespace="RedefinableElement-isConsistentWith">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-isConsistentWith-spec-_specification">
            <language>OCL</language>
            <body>result = false</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-isConsistentWith-_ownedRule.1" constrainedElement="RedefinableElement-isConsistentWith" namespace="RedefinableElement-isConsistentWith">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-isConsistentWith-_ownedRule.1-_specification">
            <language>OCL</language>
            <body>redefinee.isRedefinitionContextValid(self)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isConsistentWith-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isConsistentWith-redefinee" name="redefinee" type="RedefinableElement"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="RedefinableElement-isRedefinitionContextValid" name="isRedefinitionContextValid" class="RedefinableElement" isQuery="true" bodyCondition="RedefinableElement-isRedefinitionContextValid-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-isRedefinitionContextValid-_ownedComment.0" annotatedElement="RedefinableElement-isRedefinitionContextValid">
          <body>The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-isRedefinitionContextValid-spec" name="spec" constrainedElement="RedefinableElement-isRedefinitionContextValid" namespace="RedefinableElement-isRedefinitionContextValid">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-isRedefinitionContextValid-spec-_specification">
            <language>OCL</language>
            <body>result = self.redefinitionContext->exists(c | redefined.redefinitionContext->exists(r | c.allParents()->includes(r)))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isRedefinitionContextValid-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isRedefinitionContextValid-redefined" name="redefined" type="RedefinableElement"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Relationship" name="Relationship" isAbstract="true" superClass="Element">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Relationship-_ownedComment.0" annotatedElement="Relationship">
        <body>Relationship is an abstract concept that specifies some kind of relationship between elements.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Relationship-relatedElement" name="relatedElement" type="Element" upper="*" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_relatedElement_relationship">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Relationship-relatedElement-_ownedComment.0" annotatedElement="Relationship-relatedElement">
          <body>Specifies the elements related by the Relationship.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="StructuralFeature" name="StructuralFeature" isAbstract="true" superClass="Feature TypedElement MultiplicityElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="StructuralFeature-_ownedComment.0" annotatedElement="StructuralFeature">
        <body>A structural feature is a typed feature of a classifier that specifies the structure of instances of the classifier.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="TypedElement" name="TypedElement" isAbstract="true" superClass="NamedElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="TypedElement-_ownedComment.0" annotatedElement="TypedElement">
        <body>A typed element is a kind of named element that represents an element with a type.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="TypedElement-type" name="type" type="Type" lower="0" association="A_type_typedElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="TypedElement-type-_ownedComment.0" annotatedElement="TypedElement-type">
          <body>This information is derived from the return result for this Operation.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="ValueSpecification" name="ValueSpecification" isAbstract="true" superClass="TypedElement PackageableElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-_ownedComment.0" annotatedElement="ValueSpecification">
        <body>A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.</body>
      </ownedComment>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-isComputable" name="isComputable" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-isComputable-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-isComputable-_ownedComment.0" annotatedElement="ValueSpecification-isComputable">
          <body>The query isComputable() determines whether a value specification can be computed in a model. This operation cannot be fully defined in OCL. A conforming implementation is expected to deliver true for this operation for all value specifications that it can compute, and to compute all of those for which the operation is true. A conforming implementation is expected to be able to compute the value of all literals.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-isComputable-spec" name="spec" constrainedElement="ValueSpecification-isComputable" namespace="ValueSpecification-isComputable">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-isComputable-spec-_specification">
            <language>OCL</language>
            <body>result = false</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-isComputable-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-integerValue" name="integerValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-integerValue-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-integerValue-_ownedComment.0" annotatedElement="ValueSpecification-integerValue">
          <body>The query integerValue() gives a single Integer value when one can be computed.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-integerValue-spec" name="spec" constrainedElement="ValueSpecification-integerValue" namespace="ValueSpecification-integerValue">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-integerValue-spec-_specification">
            <language>OCL</language>
            <body>result = Set{}</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-integerValue-_ownedParameter.0" type="Integer" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-booleanValue" name="booleanValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-booleanValue-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-booleanValue-_ownedComment.0" annotatedElement="ValueSpecification-booleanValue">
          <body>The query booleanValue() gives a single Boolean value when one can be computed.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-booleanValue-spec" name="spec" constrainedElement="ValueSpecification-booleanValue" namespace="ValueSpecification-booleanValue">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-booleanValue-spec-_specification">
            <language>OCL</language>
            <body>result = Set{}</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-booleanValue-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-stringValue" name="stringValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-stringValue-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-stringValue-_ownedComment.0" annotatedElement="ValueSpecification-stringValue">
          <body>The query stringValue() gives a single String value when one can be computed.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-stringValue-spec" name="spec" constrainedElement="ValueSpecification-stringValue" namespace="ValueSpecification-stringValue">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-stringValue-spec-_specification">
            <language>OCL</language>
            <body>result = Set{}</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-stringValue-_ownedParameter.0" type="String" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-unlimitedValue" name="unlimitedValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-unlimitedValue-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-unlimitedValue-_ownedComment.0" annotatedElement="ValueSpecification-unlimitedValue">
          <body>The query unlimitedValue() gives a single UnlimitedNatural value when one can be computed.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-unlimitedValue-spec" name="spec" constrainedElement="ValueSpecification-unlimitedValue" namespace="ValueSpecification-unlimitedValue">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-unlimitedValue-spec-_specification">
            <language>OCL</language>
            <body>result = Set{}</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-unlimitedValue-_ownedParameter.0" type="UnlimitedNatural" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-isNull" name="isNull" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-isNull-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-isNull-_ownedComment.0" annotatedElement="ValueSpecification-isNull">
          <body>The query isNull() returns true when it can be computed that the value is null.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-isNull-spec" name="spec" constrainedElement="ValueSpecification-isNull" namespace="ValueSpecification-isNull">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-isNull-spec-_specification">
            <language>OCL</language>
            <body>result = false</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-isNull-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Association" name="Association" superClass="Classifier Relationship">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Association-_ownedComment.0" annotatedElement="Association">
        <body>An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.A link is a tuple with one value for each end of the association, where each value is an instance of the type of the end.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Association-association_ends" name="association_ends" constrainedElement="Association" namespace="Association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-association_ends-_ownedComment.0" annotatedElement="Association-association_ends">
          <body>Association ends of associations with more than two ends must be owned by the association.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Association-association_ends-_specification">
          <language>OCL</language>
          <body>if memberEnd->size() > 2 then ownedEnd->includesAll(memberEnd)</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Association-binary_associations" name="binary_associations" constrainedElement="Association" namespace="Association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-binary_associations-_ownedComment.0" annotatedElement="Association-binary_associations">
          <body>Only binary associations can be aggregations.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Association-binary_associations-_specification">
          <language>OCL</language>
          <body>self.memberEnd->exists(isComposite) implies self.memberEnd->size() = 2</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Association-specialized_end_number" name="specialized_end_number" constrainedElement="Association" namespace="Association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-specialized_end_number-_ownedComment.0" annotatedElement="Association-specialized_end_number">
          <body>An association specializing another association has the same number of ends as the other association.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Association-specialized_end_number-_specification">
          <language>OCL</language>
          <body>parents()->select(oclIsKindOf(Association)).oclAsType(Association)->forAll(p | p.memberEnd->size() = self.memberEnd->size())</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Association-specialized_end_types" name="specialized_end_types" constrainedElement="Association" namespace="Association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-specialized_end_types-_ownedComment.0" annotatedElement="Association-specialized_end_types">
          <body>When an association specializes another association, every end of the specific association corresponds to an end of the general association, and the specific end reaches the same type or a subtype of the more general end.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Association-specialized_end_types-_specification">
          <language>OCL</language>
          <body>Sequence{1..self.memberEnd->size()}->&#xD;&#xA;&#x9;forAll(i | self.general->select(oclIsKindOf(Association)).oclAsType(Association)->&#xD;&#xA;&#x9;&#x9;forAll(ga |self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type)))</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Association-isDerived" name="isDerived" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-isDerived-_ownedComment.0" annotatedElement="Association-isDerived">
          <body>Specifies whether the association is derived from other model elements such as other associations or constraints.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Association-ownedEnd" name="ownedEnd" type="Property" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Association-memberEnd Classifier-feature Namespace-ownedMember" association="A_ownedEnd_owningAssociation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-ownedEnd-_ownedComment.0" annotatedElement="Association-ownedEnd">
          <body>The ends that are owned by the association itself.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Association-endType" name="endType" type="Type" upper="*" isReadOnly="true" isDerived="true" subsettedProperty="Relationship-relatedElement" association="A_endType_association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-endType-_ownedComment.0" annotatedElement="Association-endType">
          <body>References the classifiers that are used as types of the ends of the association.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Association-memberEnd" name="memberEnd" type="Property" isOrdered="true" upper="*" lower="2" subsettedProperty="Namespace-member" association="A_memberEnd_association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-memberEnd-_ownedComment.0" annotatedElement="Association-memberEnd">
          <body>Each end represents participation of instances of the classifier connected to the end in links of the association.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Association-navigableOwnedEnd" name="navigableOwnedEnd" type="Property" upper="*" lower="0" subsettedProperty="Association-ownedEnd" association="A_navigableOwnedEnd_association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-navigableOwnedEnd-_ownedComment.0" annotatedElement="Association-navigableOwnedEnd">
          <body>The navigable ends that are owned by the association itself.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Association-endType.1" name="endType" class="Association" isQuery="true" bodyCondition="Association-endType.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Association-endType.1-_ownedComment.0" annotatedElement="Association-endType.1">
          <body>endType is derived from the types of the member ends.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Association-endType.1-spec" name="spec" constrainedElement="Association-endType.1 Association-endType" namespace="Association-endType.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Association-endType.1-spec-_specification">
            <language>OCL</language>
            <body>result = self.memberEnd->collect(e | e.type)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Association-endType.1-_ownedParameter.0" type="Type" isOrdered="true" upper="*" lower="0" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Class" name="Class" superClass="Classifier">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Class-_ownedComment.0" annotatedElement="Class">
        <body>A class describes a set of objects that share the same specifications of features, constraints, and semantics.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Class-isAbstract" name="isAbstract" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Class-isAbstract-_ownedComment.0" annotatedElement="Class-isAbstract">
          <body>True when a class is abstract.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Class-ownedAttribute" name="ownedAttribute" type="Property" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-attribute Namespace-ownedMember" association="A_ownedAttribute_class">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Class-ownedAttribute-_ownedComment.0" annotatedElement="Class-ownedAttribute">
          <body>The attributes (i.e. the properties) owned by the class.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Class-ownedOperation" name="ownedOperation" type="Operation" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-feature Namespace-ownedMember" association="A_ownedOperation_class">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Class-ownedOperation-_ownedComment.0" annotatedElement="Class-ownedOperation">
          <body>The operations owned by the class.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Class-superClass" name="superClass" type="Class" upper="*" lower="0" redefinedProperty="Classifier-general" association="A_superClass_class">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Class-superClass-_ownedComment.0" annotatedElement="Class-superClass">
          <body>This gives the superclasses of a class.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Class-inherit" name="inherit" class="Class" isQuery="true" redefinedOperation="Classifier-inherit" bodyCondition="Class-inherit-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Class-inherit-_ownedComment.0" annotatedElement="Class-inherit">
          <body>The inherit operation is overridden to exclude redefined properties.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Class-inherit-spec" name="spec" constrainedElement="Class-inherit" namespace="Class-inherit">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Class-inherit-spec-_specification">
            <language>OCL</language>
            <body>result = inhs->excluding(inh | ownedMember->select(oclIsKindOf(RedefinableElement))->select(redefinedElement->includes(inh)))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Class-inherit-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Class-inherit-inhs" name="inhs" type="NamedElement" upper="*" lower="0"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Property" name="Property" superClass="StructuralFeature">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Property-_ownedComment.0" annotatedElement="Property">
        <body>A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-multiplicity_of_composite" name="multiplicity_of_composite" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-multiplicity_of_composite-_ownedComment.0" annotatedElement="Property-multiplicity_of_composite">
          <body>A multiplicity of a composite aggregation must not have an upper bound greater than 1.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-multiplicity_of_composite-_specification">
          <language>OCL</language>
          <body>isComposite implies (upperBound()->isEmpty() or upperBound() &lt;= 1)</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsetting_context_conforms" name="subsetting_context_conforms" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsetting_context_conforms-_ownedComment.0" annotatedElement="Property-subsetting_context_conforms">
          <body>Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsetting_context_conforms-_specification">
          <language>OCL</language>
          <body>self.subsettedProperty->notEmpty() implies&#xA;  (self.subsettingContext()->notEmpty() and self.subsettingContext()->forAll (sc |&#xA;    self.subsettedProperty->forAll(sp |&#xA;      sp.subsettingContext()->exists(c | sc.conformsTo(c)))))</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-redefined_property_inherited" name="redefined_property_inherited" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-redefined_property_inherited-_ownedComment.0" annotatedElement="Property-redefined_property_inherited">
          <body>A redefined property must be inherited from a more general classifier containing the redefining property.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-redefined_property_inherited-_specification">
          <language>OCL</language>
          <body>if (redefinedProperty->notEmpty()) then&#xA;  (redefinitionContext->notEmpty() and&#xA;      redefinedProperty->forAll(rp|&#xA;        ((redefinitionContext->collect(fc|&#xA;          fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp))</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsetting_rules" name="subsetting_rules" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsetting_rules-_ownedComment.0" annotatedElement="Property-subsetting_rules">
          <body>A subsetting property may strengthen the type of the subsetted property, and its upper bound may be less.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsetting_rules-_specification">
          <language>OCL</language>
          <body>self.subsettedProperty->forAll(sp |&#xA;  self.type.conformsTo(sp.type) and&#xA;    ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies&#xA;      self.upperBound()&lt;=sp.upperBound() ))</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-navigable_readonly" name="navigable_readonly" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-navigable_readonly-_ownedComment.0" annotatedElement="Property-navigable_readonly">
          <body>Only a navigable property can be marked as readOnly.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-navigable_readonly-_specification">
          <language>OCL</language>
          <body>isReadOnly implies isNavigable()</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-derived_union_is_derived" name="derived_union_is_derived" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-derived_union_is_derived-_ownedComment.0" annotatedElement="Property-derived_union_is_derived">
          <body>A derived union is derived.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-derived_union_is_derived-_specification">
          <language>OCL</language>
          <body>isDerivedUnion implies isDerived</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsetted_property_names" name="subsetted_property_names" constrainedElement="Property" namespace="Property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsetted_property_names-_ownedComment.0" annotatedElement="Property-subsetted_property_names">
          <body>A property may not subset a property with the same name.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsetted_property_names-_specification">
          <language>OCL</language>
          <body>true</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isReadOnly" name="isReadOnly" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isReadOnly-_ownedComment.0" annotatedElement="Property-isReadOnly">
          <body>If isReadOnly is true, the attribute may not be written to after initialization.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-default" name="default" type="String" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-default-_ownedComment.0" annotatedElement="Property-default">
          <body>Specifies a String that represents a value to be used when no argument is supplied for the Property.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isComposite" name="isComposite" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isComposite-_ownedComment.0" annotatedElement="Property-isComposite">
          <body>If isComposite is true, the object containing the attribute is a container for the object or value contained in the attribute.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isDerived" name="isDerived" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isDerived-_ownedComment.0" annotatedElement="Property-isDerived">
          <body>If isDerived is true, the value of the attribute is derived from information elsewhere.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isDerivedUnion" name="isDerivedUnion" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isDerivedUnion-_ownedComment.0" annotatedElement="Property-isDerivedUnion">
          <body>Specifies whether the property is derived as the union of all of the properties that are constrained to subset it.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-class" name="class" type="Class" lower="0" subsettedProperty="NamedElement-namespace Feature-featuringClassifier A_attribute_classifier-classifier" association="A_ownedAttribute_class">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-class-_ownedComment.0" annotatedElement="Property-class">
          <body>References the Class that owns the Property.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-owningAssociation" name="owningAssociation" type="Association" lower="0" subsettedProperty="Property-association NamedElement-namespace Feature-featuringClassifier" association="A_ownedEnd_owningAssociation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-owningAssociation-_ownedComment.0" annotatedElement="Property-owningAssociation">
          <body>References the owning association of this property, if any.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-redefinedProperty" name="redefinedProperty" type="Property" upper="*" lower="0" subsettedProperty="RedefinableElement-redefinedElement" association="A_redefinedProperty_property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-redefinedProperty-_ownedComment.0" annotatedElement="Property-redefinedProperty">
          <body>References the properties that are redefined by this property.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-subsettedProperty" name="subsettedProperty" type="Property" upper="*" lower="0" association="A_subsettedProperty_property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsettedProperty-_ownedComment.0" annotatedElement="Property-subsettedProperty">
          <body>References the properties of which this property is constrained to be a subset.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-opposite" name="opposite" type="Property" lower="0" isDerived="true" association="A_opposite_property">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-opposite-_ownedComment.0" annotatedElement="Property-opposite">
          <body>In the case where the property is one navigable end of a binary association with both ends navigable, this gives the other end.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-datatype" name="datatype" type="DataType" lower="0" subsettedProperty="NamedElement-namespace Feature-featuringClassifier A_attribute_classifier-classifier" association="A_ownedAttribute_datatype">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-datatype-_ownedComment.0" annotatedElement="Property-datatype">
          <body>The DataType that owns this Property.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Property-association" name="association" type="Association" lower="0" association="A_memberEnd_association">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-association-_ownedComment.0" annotatedElement="Property-association">
          <body>References the association of which this property is a member, if any.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Property-opposite.1" name="opposite" class="Property" isQuery="true" bodyCondition="Property-opposite.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-opposite.1-_ownedComment.0" annotatedElement="Property-opposite.1">
          <body>If this property is owned by a class, associated with a binary association, and the other end of the association is also owned by a class, then opposite gives the other end.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-opposite.1-spec" name="spec" constrainedElement="Property-opposite.1 Property-opposite" namespace="Property-opposite.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-opposite.1-spec-_specification">
            <language>OCL</language>
            <body>result = if owningAssociation->isEmpty() and association.memberEnd->size() = 2&#xA;  then&#xA;    let otherEnd = (association.memberEnd - self)->any() in&#xA;      if otherEnd.owningAssociation->isEmpty() then otherEnd else Set{} endif&#xA;    else Set {}&#xA;    endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-opposite.1-_ownedParameter.0" type="Property" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Property-isConsistentWith" name="isConsistentWith" class="Property" isQuery="true" precondition="Property-isConsistentWith-_ownedRule.0" redefinedOperation="RedefinableElement-isConsistentWith" bodyCondition="Property-isConsistentWith-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isConsistentWith-_ownedComment.0" annotatedElement="Property-isConsistentWith">
          <body>The query isConsistentWith() specifies, for any two Properties in a context in which redefinition is possible, whether redefinition would be logically consistent. A redefining property is consistent with a redefined property if the type of the redefining property conforms to the type of the redefined property, the multiplicity of the redefining property (if specified) is contained in the multiplicity of the redefined property, and the redefining property is derived if the redefined property is derived.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isConsistentWith-_ownedRule.0" constrainedElement="Property-isConsistentWith" namespace="Property-isConsistentWith">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isConsistentWith-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>redefinee.isRedefinitionContextValid(self)</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isConsistentWith-spec" name="spec" constrainedElement="Property-isConsistentWith" namespace="Property-isConsistentWith">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isConsistentWith-spec-_specification">
            <language>OCL</language>
            <body>result = redefinee.oclIsKindOf(Property) and &#xA;  let prop : Property = redefinee.oclAsType(Property) in &#xA;  (prop.type.conformsTo(self.type) and &#xA;  ((prop.lowerBound()->notEmpty() and self.lowerBound()->notEmpty()) implies prop.lowerBound() >= self.lowerBound()) and &#xA;  ((prop.upperBound()->notEmpty() and self.upperBound()->notEmpty()) implies prop.lowerBound() &lt;= self.lowerBound()) and &#xA;  (self.isDerived implies prop.isDerived) and&#xA;  (self.isComposite implies prop.isComposite))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isConsistentWith-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isConsistentWith-redefinee" name="redefinee" type="RedefinableElement"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Property-subsettingContext" name="subsettingContext" class="Property" isQuery="true" bodyCondition="Property-subsettingContext-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsettingContext-_ownedComment.0" annotatedElement="Property-subsettingContext">
          <body>The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the corresponding classifier, and in the case of an association end, all of the classifiers at the other ends.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsettingContext-spec" name="spec" constrainedElement="Property-subsettingContext" namespace="Property-subsettingContext">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsettingContext-spec-_specification">
            <language>OCL</language>
            <body>result = if association->notEmpty()&#xA;then association.endType-type &#xA;else if classifier->notEmpty then Set{classifier} else Set{} endif&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-subsettingContext-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Property-isNavigable" name="isNavigable" class="Property" isQuery="true" bodyCondition="Property-isNavigable-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isNavigable-_ownedComment.0" annotatedElement="Property-isNavigable">
          <body>The query isNavigable() indicates whether it is possible to navigate across the property.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isNavigable-spec" name="spec" constrainedElement="Property-isNavigable" namespace="Property-isNavigable">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isNavigable-spec-_specification">
            <language>OCL</language>
            <body>result = not classifier->isEmpty() or&#xA;association.owningAssociation.navigableOwnedEnd->includes(self)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isNavigable-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Property-isAttribute" name="isAttribute" class="Property" isQuery="true" bodyCondition="Property-isAttribute-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Property-isAttribute-_ownedComment.0" annotatedElement="Property-isAttribute">
          <body>The query isAttribute() is true if the Property is defined as an attribute of some classifier.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isAttribute-spec" name="spec" constrainedElement="Property-isAttribute" namespace="Property-isAttribute">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isAttribute-spec-_specification">
            <language>OCL</language>
            <body>result = Classifier->allInstances->exists(c | c.attribute->includes(p))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isAttribute-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isAttribute-p" name="p" type="Property"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="DataType" name="DataType" superClass="Classifier">
      <ownedComment xmi:type="cmof:Comment" xmi:id="DataType-_ownedComment.0" annotatedElement="DataType">
        <body>A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="DataType-ownedAttribute" name="ownedAttribute" type="Property" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-attribute Namespace-ownedMember" association="A_ownedAttribute_datatype">
        <ownedComment xmi:type="cmof:Comment" xmi:id="DataType-ownedAttribute-_ownedComment.0" annotatedElement="DataType-ownedAttribute">
          <body>The Attributes owned by the DataType.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="DataType-ownedOperation" name="ownedOperation" type="Operation" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-feature Namespace-ownedMember" association="A_ownedOperation_datatype">
        <ownedComment xmi:type="cmof:Comment" xmi:id="DataType-ownedOperation-_ownedComment.0" annotatedElement="DataType-ownedOperation">
          <body>The Operations owned by the DataType.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="DataType-inherit" name="inherit" class="DataType" isQuery="true" redefinedOperation="Classifier-inherit" bodyCondition="DataType-inherit-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="DataType-inherit-_ownedComment.0" annotatedElement="DataType-inherit">
          <body>The inherit operation is overridden to exclude redefined properties.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="DataType-inherit-spec" name="spec" constrainedElement="DataType-inherit" namespace="DataType-inherit">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="DataType-inherit-spec-_specification">
            <language>OCL</language>
            <body>result = inhs->excluding(inh | ownedMember->select(oclIsKindOf(RedefinableElement))->select(redefinedElement->includes(inh)))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="DataType-inherit-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="DataType-inherit-inhs" name="inhs" type="NamedElement" upper="*" lower="0"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Enumeration" name="Enumeration" superClass="DataType">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Enumeration-_ownedComment.0" annotatedElement="Enumeration">
        <body>An enumeration is a data type whose values are enumerated in the model as enumeration literals.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Enumeration-ownedLiteral" name="ownedLiteral" type="EnumerationLiteral" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_ownedLiteral_enumeration">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Enumeration-ownedLiteral-_ownedComment.0" annotatedElement="Enumeration-ownedLiteral">
          <body>The ordered set of literals for this Enumeration.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="EnumerationLiteral" name="EnumerationLiteral" superClass="NamedElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="EnumerationLiteral-_ownedComment.0" annotatedElement="EnumerationLiteral">
        <body>An enumeration literal is a user-defined data value for an enumeration.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="EnumerationLiteral-enumeration" name="enumeration" type="Enumeration" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedLiteral_enumeration">
        <ownedComment xmi:type="cmof:Comment" xmi:id="EnumerationLiteral-enumeration-_ownedComment.0" annotatedElement="EnumerationLiteral-enumeration">
          <body>The Enumeration that this EnumerationLiteral is a member of.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="PrimitiveType" name="PrimitiveType" superClass="DataType">
      <ownedComment xmi:type="cmof:Comment" xmi:id="PrimitiveType-_ownedComment.0" annotatedElement="PrimitiveType">
        <body>A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.</body>
      </ownedComment>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Constraint" name="Constraint" superClass="PackageableElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-_ownedComment.0" annotatedElement="Constraint">
        <body>A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Constraint-not_apply_to_self" name="not_apply_to_self" constrainedElement="Constraint" namespace="Constraint">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-not_apply_to_self-_ownedComment.0" annotatedElement="Constraint-not_apply_to_self">
          <body>A constraint cannot be applied to itself.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Constraint-not_apply_to_self-_specification">
          <language>OCL</language>
          <body>not constrainedElement->includes(self)</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Constraint-value_specification_boolean" name="value_specification_boolean" constrainedElement="Constraint" namespace="Constraint">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-value_specification_boolean-_ownedComment.0" annotatedElement="Constraint-value_specification_boolean">
          <body>The value specification for a constraint must evaluate to a Boolean value.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Constraint-value_specification_boolean-_specification">
          <language>OCL</language>
          <body>self.specification().booleanValue().isOclKindOf(Boolean)</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Constraint-constrainedElement" name="constrainedElement" type="Element" isOrdered="true" upper="*" lower="0" association="A_constrainedElement_constraint">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-constrainedElement-_ownedComment.0" annotatedElement="Constraint-constrainedElement">
          <body>The ordered set of Elements referenced by this Constraint.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Constraint-specification" name="specification" type="ValueSpecification" isComposite="true" subsettedProperty="Element-ownedElement" association="A_specification_owningConstraint">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-specification-_ownedComment.0" annotatedElement="Constraint-specification">
          <body>A condition that must be true when evaluated in order for the constraint to be satisfied.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Constraint-context" name="context" type="Namespace" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedRule_context"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="OpaqueExpression" name="OpaqueExpression" superClass="ValueSpecification">
      <ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-_ownedComment.0" annotatedElement="OpaqueExpression">
        <body>An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="OpaqueExpression-language_body_size" name="language_body_size" constrainedElement="OpaqueExpression" namespace="OpaqueExpression">
        <ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-language_body_size-_ownedComment.0" annotatedElement="OpaqueExpression-language_body_size">
          <body>If the language attribute is not empty, then the size of the body and language arrays must be the same.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="OpaqueExpression-language_body_size-_specification">
          <language>OCL</language>
          <body>language->notEmpty() implies (body->size() = language->size())</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="OpaqueExpression-body" name="body" type="String" isOrdered="true" isUnique="false" upper="*" lower="0" isComposite="true">
        <ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-body-_ownedComment.0" annotatedElement="OpaqueExpression-body">
          <body>The text of the expression, possibly in multiple languages.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="OpaqueExpression-language" name="language" type="String" isOrdered="true" upper="*" lower="0" isComposite="true">
        <ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-language-_ownedComment.0" annotatedElement="OpaqueExpression-language">
          <body>Specifies the languages in which the expression is stated. The interpretation of the expression body depends on the languages. If the languages are unspecified, they might be implicit from the expression body or the context. Languages are matched to body strings by order.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Operation" name="Operation" superClass="BehavioralFeature">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-_ownedComment.0" annotatedElement="Operation">
        <body>An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-only_body_for_query" name="only_body_for_query" constrainedElement="Operation" namespace="Operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-only_body_for_query-_ownedComment.0" annotatedElement="Operation-only_body_for_query">
          <body>A bodyCondition can only be specified for a query operation.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-only_body_for_query-_specification">
          <language>OCL</language>
          <body>bodyCondition->notEmpty() implies isQuery</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-at_most_one_return" name="at_most_one_return" constrainedElement="Operation" namespace="Operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-at_most_one_return-_ownedComment.0" annotatedElement="Operation-at_most_one_return">
          <body>An operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return'</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-at_most_one_return-_specification">
          <language>OCL</language>
          <body>self.ownedParameter->select(par | par.direction = #return)->size() &lt;= 1</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-isQuery" name="isQuery" type="Boolean" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isQuery-_ownedComment.0" annotatedElement="Operation-isQuery">
          <body>Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged (isQuery=true) or whether side effects may occur (isQuery=false).</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-isOrdered" name="isOrdered" type="Boolean" isDerived="true" default="false">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isOrdered-_ownedComment.0" annotatedElement="Operation-isOrdered">
          <body>This information is derived from the return result for this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-isUnique" name="isUnique" type="Boolean" isDerived="true" default="true">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isUnique-_ownedComment.0" annotatedElement="Operation-isUnique">
          <body>This information is derived from the return result for this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-lower" name="lower" type="Integer" lower="0" isDerived="true" default="1">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-lower-_ownedComment.0" annotatedElement="Operation-lower">
          <body>This information is derived from the return result for this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-upper" name="upper" type="UnlimitedNatural" lower="0" isDerived="true" default="1">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-upper-_ownedComment.0" annotatedElement="Operation-upper">
          <body>This information is derived from the return result for this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-class" name="class" type="Class" lower="0" subsettedProperty="RedefinableElement-redefinitionContext NamedElement-namespace Feature-featuringClassifier" association="A_ownedOperation_class">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-class-_ownedComment.0" annotatedElement="Operation-class">
          <body>The class that owns the operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-datatype" name="datatype" type="DataType" lower="0" subsettedProperty="RedefinableElement-redefinitionContext NamedElement-namespace Feature-featuringClassifier" association="A_ownedOperation_datatype">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-datatype-_ownedComment.0" annotatedElement="Operation-datatype">
          <body>The DataType that owns this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-raisedException" name="raisedException" type="Type" upper="*" lower="0" redefinedProperty="BehavioralFeature-raisedException" association="A_raisedException_operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-raisedException-_ownedComment.0" annotatedElement="Operation-raisedException">
          <body>References the Types representing exceptions that may be raised during an invocation of this operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-redefinedOperation" name="redefinedOperation" type="Operation" upper="*" lower="0" subsettedProperty="RedefinableElement-redefinedElement" association="A_redefinedOperation_operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-redefinedOperation-_ownedComment.0" annotatedElement="Operation-redefinedOperation">
          <body>References the Operations that are redefined by this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-type" name="type" type="Type" lower="0" isDerived="true" association="A_type_operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-type-_ownedComment.0" annotatedElement="Operation-type">
          <body>This information is derived from the return result for this Operation.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-ownedParameter" name="ownedParameter" type="Parameter" isOrdered="true" upper="*" lower="0" isComposite="true" redefinedProperty="BehavioralFeature-ownedParameter" association="A_ownedParameter_operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-ownedParameter-_ownedComment.0" annotatedElement="Operation-ownedParameter">
          <body>Specifies the ordered set of formal parameters of this BehavioralFeature.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-precondition" name="precondition" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_precondition_preContext"/>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-postcondition" name="postcondition" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_postcondition_postContext"/>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-bodyCondition" name="bodyCondition" type="Constraint" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_bodyCondition_bodyContext"/>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-isOrdered.1" name="isOrdered" class="Operation" isQuery="true" bodyCondition="Operation-isOrdered.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isOrdered.1-_ownedComment.0" annotatedElement="Operation-isOrdered.1">
          <body>If this operation has a return parameter, isOrdered equals the value of isOrdered for that parameter. Otherwise isOrdered is false.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isOrdered.1-spec" name="spec" constrainedElement="Operation-isOrdered.1 Operation-isOrdered" namespace="Operation-isOrdered.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isOrdered.1-spec-_specification">
            <language>OCL</language>
            <body>result = if returnResult->size() = 1 then returnResult->any().isOrdered else false endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isOrdered.1-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-isUnique.1" name="isUnique" class="Operation" isQuery="true" bodyCondition="Operation-isUnique.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isUnique.1-_ownedComment.0" annotatedElement="Operation-isUnique.1">
          <body>If this operation has a return parameter, isUnique equals the value of isUnique for that parameter. Otherwise isUnique is true.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isUnique.1-spec" name="spec" constrainedElement="Operation-isUnique.1 Operation-isUnique" namespace="Operation-isUnique.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isUnique.1-spec-_specification">
            <language>OCL</language>
            <body>result = if returnResult->size() = 1 then returnResult->any().isUnique else true endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isUnique.1-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-lower.1" name="lower" class="Operation" isQuery="true" bodyCondition="Operation-lower.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-lower.1-_ownedComment.0" annotatedElement="Operation-lower.1">
          <body>If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower is not defined.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-lower.1-spec" name="spec" constrainedElement="Operation-lower.1 Operation-lower" namespace="Operation-lower.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-lower.1-spec-_specification">
            <language>OCL</language>
            <body>result = if returnResult->size() = 1 then returnResult->any().lower else Set{} endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-lower.1-_ownedParameter.0" type="Integer" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-upper.1" name="upper" class="Operation" isQuery="true" bodyCondition="Operation-upper.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-upper.1-_ownedComment.0" annotatedElement="Operation-upper.1">
          <body>If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper is not defined.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-upper.1-spec" name="spec" constrainedElement="Operation-upper.1 Operation-upper" namespace="Operation-upper.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-upper.1-spec-_specification">
            <language>OCL</language>
            <body>result = if returnResult->size() = 1 then returnResult->any().upper else Set{} endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-upper.1-_ownedParameter.0" type="UnlimitedNatural" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-type.1" name="type" class="Operation" isQuery="true" bodyCondition="Operation-type.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-type.1-_ownedComment.0" annotatedElement="Operation-type.1">
          <body>If this operation has a return parameter, type equals the value of type for that parameter. Otherwise type is not defined.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-type.1-spec" name="spec" constrainedElement="Operation-type.1 Operation-type" namespace="Operation-type.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-type.1-spec-_specification">
            <language>OCL</language>
            <body>result = if returnResult->size() = 1 then returnResult->any().type else Set{} endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-type.1-_ownedParameter.0" type="Type" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-isConsistentWith" name="isConsistentWith" class="Operation" isQuery="true" precondition="Operation-isConsistentWith-_ownedRule.0" redefinedOperation="RedefinableElement-isConsistentWith" bodyCondition="Operation-isConsistentWith-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isConsistentWith-_ownedComment.0" annotatedElement="Operation-isConsistentWith">
          <body>The query isConsistentWith() specifies, for any two Operations in a context in which redefinition is possible, whether redefinition would be consistent in the sense of maintaining type covariance. Other senses of consistency may be required, for example to determine consistency in the sense of contravariance. Users may define alternative queries under names different from 'isConsistentWith()', as for example, users may define a query named 'isContravariantWith()'.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isConsistentWith-_ownedRule.0" constrainedElement="Operation-isConsistentWith" namespace="Operation-isConsistentWith">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isConsistentWith-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>redefinee.isRedefinitionContextValid(self)</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isConsistentWith-spec" name="spec" constrainedElement="Operation-isConsistentWith" namespace="Operation-isConsistentWith">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isConsistentWith-spec-_specification">
            <language>OCL</language>
            <body>result = (redefinee.oclIsKindOf(Operation) and&#xD;&#xA;let op: Operation = redefinee.oclAsType(Operation) in&#xD;&#xA;self.ownedParameter.size() = op.ownedParameter.size() and&#xD;&#xA;forAll(i | op.ownedParameter[i].type.conformsTo(self.ownedParameter[i].type))&#xD;&#xA;)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isConsistentWith-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isConsistentWith-redefinee" name="redefinee" type="RedefinableElement"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-returnResult" name="returnResult" class="Operation" isQuery="true" bodyCondition="Operation-returnResult-spec">
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-returnResult-spec" name="spec" constrainedElement="Operation-returnResult" namespace="Operation-returnResult">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-returnResult-spec-_specification">
            <language>OCL</language>
            <body>result = ownedParameter->select (par | par.direction = #return)</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-returnResult-_ownedParameter.0" type="Parameter" upper="*" lower="0" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Parameter" name="Parameter" superClass="TypedElement MultiplicityElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-_ownedComment.0" annotatedElement="Parameter">
        <body>A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Parameter-default" name="default" type="String" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-default-_ownedComment.0" annotatedElement="Parameter-default">
          <body>Specifies a String that represents a value to be used when no argument is supplied for the Parameter.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Parameter-direction" name="direction" type="ParameterDirectionKind" default="in">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-direction-_ownedComment.0" annotatedElement="Parameter-direction">
          <body>Indicates whether a parameter is being sent into or out of a behavioral element.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Parameter-operation" name="operation" type="Operation" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedParameter_operation">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-operation-_ownedComment.0" annotatedElement="Parameter-operation">
          <body>References the Operation owning this parameter.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="BehavioralFeature" name="BehavioralFeature" isAbstract="true" superClass="Feature Namespace">
      <ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-_ownedComment.0" annotatedElement="BehavioralFeature">
        <body>A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="BehavioralFeature-ownedParameter" name="ownedParameter" type="Parameter" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_ownedParameter_ownerFormalParam">
        <ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-ownedParameter-_ownedComment.0" annotatedElement="BehavioralFeature-ownedParameter">
          <body>Specifies the ordered set of formal parameters of this BehavioralFeature.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="BehavioralFeature-raisedException" name="raisedException" type="Type" upper="*" lower="0" association="A_raisedException_behavioralFeature">
        <ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-raisedException-_ownedComment.0" annotatedElement="BehavioralFeature-raisedException">
          <body>References the Types representing exceptions that may be raised during an invocation of this feature.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="BehavioralFeature-isDistinguishableFrom" name="isDistinguishableFrom" class="BehavioralFeature" isQuery="true" redefinedOperation="NamedElement-isDistinguishableFrom" bodyCondition="BehavioralFeature-isDistinguishableFrom-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-isDistinguishableFrom-_ownedComment.0" annotatedElement="BehavioralFeature-isDistinguishableFrom">
          <body>The query isDistinguishableFrom() determines whether two BehavioralFeatures may coexist in the same Namespace. It specifies that they have to have different signatures.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="BehavioralFeature-isDistinguishableFrom-spec" name="spec" constrainedElement="BehavioralFeature-isDistinguishableFrom" namespace="BehavioralFeature-isDistinguishableFrom">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="BehavioralFeature-isDistinguishableFrom-spec-_specification">
            <language>OCL</language>
            <body>result = if n.oclIsKindOf(BehavioralFeature)&#xA;then&#xA;  if ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->notEmpty()&#xA;  then Set{}->include(self)->include(n)->isUnique( bf | bf.parameter->collect(type))&#xA;  else true&#xA;  endif&#xA;else true&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="BehavioralFeature-isDistinguishableFrom-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="BehavioralFeature-isDistinguishableFrom-n" name="n" type="NamedElement"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="BehavioralFeature-isDistinguishableFrom-ns" name="ns" type="Namespace"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="ElementImport" name="ElementImport" superClass="DirectedRelationship">
      <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-_ownedComment.0" annotatedElement="ElementImport">
        <body>An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="ElementImport-visibility_public_or_private" name="visibility_public_or_private" constrainedElement="ElementImport" namespace="ElementImport">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-visibility_public_or_private-_ownedComment.0" annotatedElement="ElementImport-visibility_public_or_private">
          <body>The visibility of an ElementImport is either public or private.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="ElementImport-visibility_public_or_private-_specification">
          <language>OCL</language>
          <body>self.visibility = #public or self.visibility = #private</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="ElementImport-imported_element_is_public" name="imported_element_is_public" constrainedElement="ElementImport" namespace="ElementImport">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-imported_element_is_public-_ownedComment.0" annotatedElement="ElementImport-imported_element_is_public">
          <body>An importedElement has either public visibility or no visibility at all.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="ElementImport-imported_element_is_public-_specification">
          <language>OCL</language>
          <body>self.importedElement.visibility.notEmpty() implies self.importedElement.visibility = #public</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-visibility" name="visibility" type="VisibilityKind" default="public">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-visibility-_ownedComment.0" annotatedElement="ElementImport-visibility">
          <body>Specifies the visibility of the imported PackageableElement within the importing Package. The default visibility is the same as that of the imported element. If the imported element does not have a visibility, it is possible to add visibility to the element import.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-alias" name="alias" type="String" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-alias-_ownedComment.0" annotatedElement="ElementImport-alias">
          <body>Specifies the name that should be added to the namespace of the importing package in lieu of the name of the imported packagable element. The aliased name must not clash with any other member name in the importing package. By default, no alias is used.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-importedElement" name="importedElement" type="PackageableElement" subsettedProperty="DirectedRelationship-target" association="A_importedElement_elementImport">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-importedElement-_ownedComment.0" annotatedElement="ElementImport-importedElement">
          <body>Specifies the PackageableElement whose name is to be added to a Namespace.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-importingNamespace" name="importingNamespace" type="Namespace" subsettedProperty="DirectedRelationship-source Element-owner" association="A_elementImport_importingNamespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-importingNamespace-_ownedComment.0" annotatedElement="ElementImport-importingNamespace">
          <body>Specifies the Namespace that imports a PackageableElement from another Package.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="ElementImport-getName" name="getName" class="ElementImport" isQuery="true" bodyCondition="ElementImport-getName-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-getName-_ownedComment.0" annotatedElement="ElementImport-getName">
          <body>The query getName() returns the name under which the imported PackageableElement will be known in the importing namespace.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="ElementImport-getName-spec" name="spec" constrainedElement="ElementImport-getName" namespace="ElementImport-getName">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="ElementImport-getName-spec-_specification">
            <language>OCL</language>
            <body>result = if self.alias->notEmpty() then &#xA;  self.alias&#xA;else&#xA;  self.importedElement.name&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="ElementImport-getName-_ownedParameter.0" type="String" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Package" name="Package" superClass="PackageableElement Namespace">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Package-_ownedComment.0" annotatedElement="Package">
        <body>A package is used to group elements, and provides a namespace for the grouped elements.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="Package-elements_public_or_private" name="elements_public_or_private" constrainedElement="Package" namespace="Package">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-elements_public_or_private-_ownedComment.0" annotatedElement="Package-elements_public_or_private">
          <body>If an element that is owned by a package has visibility, it is public or private.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-elements_public_or_private-_specification">
          <language>OCL</language>
          <body>self.ownedElements->forAll(e | e.visibility->notEmpty() implies e.visbility = #public or e.visibility = #private)</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Package-packagedElement" name="packagedElement" type="PackageableElement" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_packagedElement_owningPackage">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-packagedElement-_ownedComment.0" annotatedElement="Package-packagedElement">
          <body>Specifies the packageable elements that are owned by this Package.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Package-ownedType" name="ownedType" type="Type" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="Package-packagedElement" association="A_ownedType_package">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-ownedType-_ownedComment.0" annotatedElement="Package-ownedType">
          <body>References the packaged elements that are Types.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Package-nestedPackage" name="nestedPackage" type="Package" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="Package-packagedElement" association="A_nestedPackage_nestingPackage">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-nestedPackage-_ownedComment.0" annotatedElement="Package-nestedPackage">
          <body>References the packaged elements that are Packages.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Package-nestingPackage" name="nestingPackage" type="Package" lower="0" subsettedProperty="NamedElement-namespace" association="A_nestedPackage_nestingPackage">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-nestingPackage-_ownedComment.0" annotatedElement="Package-nestingPackage">
          <body>References the Package that owns this Package.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Package-packageMerge" name="packageMerge" type="PackageMerge" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_packageMerge_receivingPackage">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-packageMerge-_ownedComment.0" annotatedElement="Package-packageMerge">
          <body>References the PackageMerges that are owned by this Package.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Package-uri" name="uri" type="String" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-uri-_ownedComment.0" annotatedElement="Package-uri">
          <body>Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt. UML 1.4 and MOF 1.4 were assigned URIs to their outermost package. The package URI appears in XMI files when instances of the packages classes are serialized.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Package-mustBeOwned" name="mustBeOwned" class="Package" isQuery="true" redefinedOperation="Element-mustBeOwned" bodyCondition="Package-mustBeOwned-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-mustBeOwned-_ownedComment.0" annotatedElement="Package-mustBeOwned">
          <body>The query mustBeOwned() indicates whether elements of this type must have an owner.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Package-mustBeOwned-spec" name="spec" constrainedElement="Package-mustBeOwned" namespace="Package-mustBeOwned">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-mustBeOwned-spec-_specification">
            <language>OCL</language>
            <body>result = false</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-mustBeOwned-_ownedParameter.0" type="Boolean" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Package-visibleMembers" name="visibleMembers" class="Package" isQuery="true" bodyCondition="Package-visibleMembers-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-visibleMembers-_ownedComment.0" annotatedElement="Package-visibleMembers">
          <body>The query visibleMembers() defines which members of a Package can be accessed outside it.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Package-visibleMembers-spec" name="spec" constrainedElement="Package-visibleMembers" namespace="Package-visibleMembers">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-visibleMembers-spec-_specification">
            <language>OCL</language>
            <body>result = member->select( m | self.makesVisible(m))</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-visibleMembers-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Package-makesVisible" name="makesVisible" class="Package" isQuery="true" precondition="Package-makesVisible-_ownedRule.0" bodyCondition="Package-makesVisible-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Package-makesVisible-_ownedComment.0" annotatedElement="Package-makesVisible">
          <body>The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Package-makesVisible-_ownedRule.0" constrainedElement="Package-makesVisible" namespace="Package-makesVisible">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-makesVisible-_ownedRule.0-_specification">
            <language>OCL</language>
            <body>self.member->includes(el)</body>
          </specification>
        </ownedRule>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Package-makesVisible-spec" name="spec" constrainedElement="Package-makesVisible" namespace="Package-makesVisible">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-makesVisible-spec-_specification">
            <language>OCL</language>
            <body>result = (ownedMember->includes(el)) or&#xA;   (elementImport->&#xA;      select(ei|ei.visibility = #public)->&#xA;         collect(ei|ei.importedElement)->includes(el)) or&#xA;   (packageImport->&#xA;      select(pi|pi.visibility = #public)->&#xA;        collect(pi|&#xA;           pi.importedPackage.member->includes(el))->notEmpty())</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-makesVisible-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-makesVisible-el" name="el" type="NamedElement"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="PackageImport" name="PackageImport" superClass="DirectedRelationship">
      <ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-_ownedComment.0" annotatedElement="PackageImport">
        <body>A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="PackageImport-public_or_private" name="public_or_private" constrainedElement="PackageImport" namespace="PackageImport">
        <ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-public_or_private-_ownedComment.0" annotatedElement="PackageImport-public_or_private">
          <body>The visibility of a PackageImport is either public or private.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="PackageImport-public_or_private-_specification">
          <language>OCL</language>
          <body>self.visibility = #public or self.visibility = #private</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="PackageImport-visibility" name="visibility" type="VisibilityKind" default="public">
        <ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-visibility-_ownedComment.0" annotatedElement="PackageImport-visibility">
          <body>Specifies the visibility of the imported PackageableElements within the importing Namespace, i.e., whether imported elements will in turn be visible to other packages that use that importingPackage as an importedPackage. If the PackageImport is public, the imported elements will be visible outside the package, while if it is private they will not.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="PackageImport-importedPackage" name="importedPackage" type="Package" subsettedProperty="DirectedRelationship-target" association="A_importedPackage_packageImport">
        <ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-importedPackage-_ownedComment.0" annotatedElement="PackageImport-importedPackage">
          <body>Specifies the Package whose members are imported into a Namespace.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="PackageImport-importingNamespace" name="importingNamespace" type="Namespace" subsettedProperty="DirectedRelationship-source Element-owner" association="A_packageImport_importingNamespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-importingNamespace-_ownedComment.0" annotatedElement="PackageImport-importingNamespace">
          <body>Specifies the Namespace that imports the members from a Package.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="PackageMerge" name="PackageMerge" superClass="DirectedRelationship">
      <ownedComment xmi:type="cmof:Comment" xmi:id="PackageMerge-_ownedComment.0" annotatedElement="PackageMerge">
        <body>A package merge defines how the contents of one package are extended by the contents of another package.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="PackageMerge-receivingPackage" name="receivingPackage" type="Package" subsettedProperty="DirectedRelationship-source Element-owner" association="A_packageMerge_receivingPackage">
        <ownedComment xmi:type="cmof:Comment" xmi:id="PackageMerge-receivingPackage-_ownedComment.0" annotatedElement="PackageMerge-receivingPackage">
          <body>References the Package that is being extended with the contents of the merged package of the PackageMerge.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="PackageMerge-mergedPackage" name="mergedPackage" type="Package" subsettedProperty="DirectedRelationship-target" association="A_mergedPackage_packageMerge">
        <ownedComment xmi:type="cmof:Comment" xmi:id="PackageMerge-mergedPackage-_ownedComment.0" annotatedElement="PackageMerge-mergedPackage">
          <body>References the Package that is to be merged with the receiving package of the PackageMerge.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Type" name="Type" isAbstract="true" superClass="NamedElement PackageableElement">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Type-_ownedComment.0" annotatedElement="Type">
        <body>A type is a named element that is used as the type for a typed element. A type can be contained in a package.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Type-package" name="package" type="Package" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedType_package">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Type-package-_ownedComment.0" annotatedElement="Type-package">
          <body>Specifies the owning package of this classifier, if any.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="Type-conformsTo" name="conformsTo" class="Type" isQuery="true" bodyCondition="Type-conformsTo-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Type-conformsTo-_ownedComment.0" annotatedElement="Type-conformsTo">
          <body>The query conformsTo() gives true for a type that conforms to another. By default, two types do not conform to each other. This query is intended to be redefined for specific conformance situations.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="Type-conformsTo-spec" name="spec" constrainedElement="Type-conformsTo" namespace="Type-conformsTo">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="Type-conformsTo-spec-_specification">
            <language>OCL</language>
            <body>result = false</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Type-conformsTo-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="Type-conformsTo-other" name="other" type="Type"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="NamedElement" name="NamedElement" isAbstract="true" superClass="Element">
      <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-_ownedComment.0" annotatedElement="NamedElement">
        <body>A named element is an element in a model that may have a name.</body>
      </ownedComment>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-has_no_qualified_name" name="has_no_qualified_name" constrainedElement="NamedElement" namespace="NamedElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-has_no_qualified_name-_ownedComment.0" annotatedElement="NamedElement-has_no_qualified_name">
          <body>If there is no name, or one of the containing namespaces has no name, there is no qualified name.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-has_no_qualified_name-_specification">
          <language>OCL</language>
          <body>(self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty())&#xD;&#xA;  implies self.qualifiedName->isEmpty()</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-has_qualified_name" name="has_qualified_name" constrainedElement="NamedElement" namespace="NamedElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-has_qualified_name-_ownedComment.0" annotatedElement="NamedElement-has_qualified_name">
          <body>When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-has_qualified_name-_specification">
          <language>OCL</language>
          <body>(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies&#xA;  self.qualifiedName = self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))</body>
        </specification>
      </ownedRule>
      <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-visibility_needs_ownership" name="visibility_needs_ownership" constrainedElement="NamedElement" namespace="NamedElement">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-visibility_needs_ownership-_ownedComment.0" annotatedElement="NamedElement-visibility_needs_ownership">
          <body>If a NamedElement is not owned by a Namespace, it does not have a visibility.</body>
        </ownedComment>
        <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-visibility_needs_ownership-_specification">
          <language>OCL</language>
          <body>namespace->isEmpty() implies visibility->isEmpty()</body>
        </specification>
      </ownedRule>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-name" name="name" type="String" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-name-_ownedComment.0" annotatedElement="NamedElement-name">
          <body>The name of the NamedElement.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-visibility" name="visibility" type="VisibilityKind" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-visibility-_ownedComment.0" annotatedElement="NamedElement-visibility">
          <body>Determines where the NamedElement appears within different Namespaces within the overall model, and its accessibility.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-namespace" name="namespace" type="Namespace" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Element-owner" association="A_ownedMember_namespace">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-namespace-_ownedComment.0" annotatedElement="NamedElement-namespace">
          <body>Specifies the namespace that owns the NamedElement.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-qualifiedName" name="qualifiedName" type="String" lower="0" isReadOnly="true" isDerived="true">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-qualifiedName-_ownedComment.0" annotatedElement="NamedElement-qualifiedName">
          <body>A name which allows the NamedElement to be identified within a hierarchy of nested Namespaces. It is constructed from the names of the containing namespaces starting at the root of the hierarchy and ending with the name of the NamedElement itself.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-allNamespaces" name="allNamespaces" class="NamedElement" isQuery="true" bodyCondition="NamedElement-allNamespaces-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-allNamespaces-_ownedComment.0" annotatedElement="NamedElement-allNamespaces">
          <body>The query allNamespaces() gives the sequence of namespaces in which the NamedElement is nested, working outwards.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-allNamespaces-spec" name="spec" constrainedElement="NamedElement-allNamespaces" namespace="NamedElement-allNamespaces">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-allNamespaces-spec-_specification">
            <language>OCL</language>
            <body>result = if self.namespace->isEmpty()&#xA;then Sequence{}&#xA;else self.namespace.allNamespaces()->prepend(self.namespace)&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-allNamespaces-_ownedParameter.0" type="Namespace" isOrdered="true" upper="*" lower="0" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-isDistinguishableFrom" name="isDistinguishableFrom" class="NamedElement" isQuery="true" bodyCondition="NamedElement-isDistinguishableFrom-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-isDistinguishableFrom-_ownedComment.0" annotatedElement="NamedElement-isDistinguishableFrom">
          <body>The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace. By default, two named elements are distinguishable if (a) they have unrelated types or (b) they have related types but different names.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-isDistinguishableFrom-spec" name="spec" constrainedElement="NamedElement-isDistinguishableFrom" namespace="NamedElement-isDistinguishableFrom">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-isDistinguishableFrom-spec-_specification">
            <language>OCL</language>
            <body>result = if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)&#xA;then ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()&#xA;else true&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-isDistinguishableFrom-_ownedParameter.0" type="Boolean" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-isDistinguishableFrom-n" name="n" type="NamedElement"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-isDistinguishableFrom-ns" name="ns" type="Namespace"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-separator" name="separator" class="NamedElement" isQuery="true" bodyCondition="NamedElement-separator-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-separator-_ownedComment.0" annotatedElement="NamedElement-separator">
          <body>The query separator() gives the string that is used to separate names when constructing a qualified name.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-separator-spec" name="spec" constrainedElement="NamedElement-separator" namespace="NamedElement-separator">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-separator-spec-_specification">
            <language>OCL</language>
            <body>result = '::'</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-separator-_ownedParameter.0" type="String" direction="return"/>
      </ownedOperation>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-qualifiedName.1" name="qualifiedName" class="NamedElement" isQuery="true" bodyCondition="NamedElement-qualifiedName.1-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-qualifiedName.1-_ownedComment.0" annotatedElement="NamedElement-qualifiedName.1">
          <body>When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-qualifiedName.1-spec" name="spec" constrainedElement="NamedElement-qualifiedName.1" namespace="NamedElement-qualifiedName.1">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-qualifiedName.1-spec-_specification">
            <language>OCL</language>
            <body>result = if self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()&#xA;then &#xA;    self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))&#xA;else&#xA;    Set{}&#xA;endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-qualifiedName.1-_ownedParameter.0" type="String" direction="return"/>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Expression" name="Expression" superClass="ValueSpecification">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Expression-_ownedComment.0" annotatedElement="Expression">
        <body>An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Expression-operand" name="operand" type="ValueSpecification" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_operand_expression">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Expression-operand-_ownedComment.0" annotatedElement="Expression-operand">
          <body>Specifies a sequence of operands.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Class" xmi:id="Comment" name="Comment" superClass="Element">
      <ownedComment xmi:type="cmof:Comment" xmi:id="Comment-_ownedComment.0" annotatedElement="Comment">
        <body>A comment is a textual annotation that can be attached to a set of elements.</body>
      </ownedComment>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Comment-body" name="body" type="String" lower="0">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Comment-body-_ownedComment.0" annotatedElement="Comment-body">
          <body>Specifies a string that is the comment.</body>
        </ownedComment>
      </ownedAttribute>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Comment-annotatedElement" name="annotatedElement" type="Element" upper="*" lower="0" association="A_annotatedElement_comment">
        <ownedComment xmi:type="cmof:Comment" xmi:id="Comment-annotatedElement-_ownedComment.0" annotatedElement="Comment-annotatedElement">
          <body>References the Element(s) being commented.</body>
        </ownedComment>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="cmof:Enumeration" xmi:id="ParameterDirectionKind" name="ParameterDirectionKind">
      <ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-_ownedComment.0" annotatedElement="ParameterDirectionKind">
        <body>Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.</body>
      </ownedComment>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-in" name="in" enumeration="ParameterDirectionKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-in-_ownedComment.0" annotatedElement="ParameterDirectionKind-in">
          <body>Indicates that parameter values are passed into the behavioral element by the caller.</body>
        </ownedComment>
      </ownedLiteral>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-inout" name="inout" enumeration="ParameterDirectionKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-inout-_ownedComment.0" annotatedElement="ParameterDirectionKind-inout">
          <body>Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.</body>
        </ownedComment>
      </ownedLiteral>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-out" name="out" enumeration="ParameterDirectionKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-out-_ownedComment.0" annotatedElement="ParameterDirectionKind-out">
          <body>Indicates that parameter values are passed from a behavioral element out to the caller.</body>
        </ownedComment>
      </ownedLiteral>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-return" name="return" enumeration="ParameterDirectionKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-return-_ownedComment.0" annotatedElement="ParameterDirectionKind-return">
          <body>Indicates that parameter values are passed as return values from a behavioral element back to the caller.</body>
        </ownedComment>
      </ownedLiteral>
    </packagedElement>
    <packagedElement xmi:type="cmof:Enumeration" xmi:id="VisibilityKind" name="VisibilityKind">
      <ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-_ownedComment.0" annotatedElement="VisibilityKind">
        <body>VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.</body>
      </ownedComment>
      <ownedOperation xmi:type="cmof:Operation" xmi:id="VisibilityKind-bestVisibility" name="bestVisibility" isQuery="true" datatype="VisibilityKind" bodyCondition="VisibilityKind-bestVisibility-spec">
        <ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-bestVisibility-_ownedComment.0" annotatedElement="VisibilityKind-bestVisibility">
          <body>The query bestVisibility() examines a set of VisibilityKinds, and returns public as the preferred visibility.</body>
        </ownedComment>
        <ownedRule xmi:type="cmof:Constraint" xmi:id="VisibilityKind-bestVisibility-spec" name="spec" constrainedElement="VisibilityKind-bestVisibility" namespace="VisibilityKind-bestVisibility">
          <specification xmi:type="cmof:OpaqueExpression" xmi:id="VisibilityKind-bestVisibility-spec-_specification">
            <language>OCL</language>
            <body>result = if vis->includes(#public) then #public else #private endif</body>
          </specification>
        </ownedRule>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="VisibilityKind-bestVisibility-_ownedParameter.0" type="VisibilityKind" direction="return"/>
        <ownedParameter xmi:type="cmof:Parameter" xmi:id="VisibilityKind-bestVisibility-vis" name="vis" type="VisibilityKind" upper="*" lower="0"/>
      </ownedOperation>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-public" name="public" enumeration="VisibilityKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-public-_ownedComment.0" annotatedElement="VisibilityKind-public">
          <body>A public element is visible to all elements that can access the contents of the namespace that owns it.</body>
        </ownedComment>
      </ownedLiteral>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-private" name="private" enumeration="VisibilityKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-private-_ownedComment.0" annotatedElement="VisibilityKind-private">
          <body>A private element is only visible inside the namespace that owns it.</body>
        </ownedComment>
      </ownedLiteral>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-protected" name="protected" enumeration="VisibilityKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-protected-_ownedComment.0" annotatedElement="VisibilityKind-protected">
          <body>A protected element is visible to elements that have a generalization relationship to the namespace that owns it.</body>
        </ownedComment>
      </ownedLiteral>
      <ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-package" name="package" enumeration="VisibilityKind">
        <ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-package-_ownedComment.0" annotatedElement="VisibilityKind-package">
          <body>A package element is owned by a namespace that is not a package, and is visible to elements that are in the same package as its owning namespace. Only named elements that are not owned by packages can be marked as having package visibility.  Any element marked as having package visibility is visible to all elements within the nearest enclosing package (given that other owning elements have proper visibility).  Outside the nearest enclosing package, an element marked as having package visibility is not visible.</body>
        </ownedComment>
      </ownedLiteral>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_type_typedElement" name="A_type_typedElement" memberEnd="TypedElement-type A_type_typedElement-typedElement">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_type_typedElement-typedElement" name="typedElement" type="TypedElement" upper="*" lower="0" owningAssociation="A_type_typedElement" association="A_type_typedElement"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedAttribute_class" name="A_ownedAttribute_class" memberEnd="Class-ownedAttribute Property-class"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedOperation_class" name="A_ownedOperation_class" memberEnd="Class-ownedOperation Operation-class"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedEnd_owningAssociation" name="A_ownedEnd_owningAssociation" memberEnd="Association-ownedEnd Property-owningAssociation"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_attribute_classifier" name="A_attribute_classifier" memberEnd="Classifier-attribute A_attribute_classifier-classifier">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_attribute_classifier-classifier" name="classifier" type="Classifier" lower="0" owningAssociation="A_attribute_classifier" subsettedProperty="RedefinableElement-redefinitionContext" association="A_attribute_classifier"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_redefinedProperty_property" name="A_redefinedProperty_property" memberEnd="Property-redefinedProperty A_redefinedProperty_property-property">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinedProperty_property-property" name="property" type="Property" upper="*" lower="0" owningAssociation="A_redefinedProperty_property" association="A_redefinedProperty_property"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_subsettedProperty_property" name="A_subsettedProperty_property" memberEnd="Property-subsettedProperty A_subsettedProperty_property-property">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_subsettedProperty_property-property" name="property" type="Property" upper="*" lower="0" owningAssociation="A_subsettedProperty_property" association="A_subsettedProperty_property"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_opposite_property" name="A_opposite_property" memberEnd="Property-opposite A_opposite_property-property">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_opposite_property-property" name="property" type="Property" lower="0" owningAssociation="A_opposite_property" association="A_opposite_property"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_superClass_class" name="A_superClass_class" memberEnd="Class-superClass A_superClass_class-class">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_superClass_class-class" name="class" type="Class" upper="*" lower="0" owningAssociation="A_superClass_class" association="A_superClass_class"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_endType_association" name="A_endType_association" memberEnd="Association-endType A_endType_association-association">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_endType_association-association" name="association" type="Association" upper="*" lower="0" owningAssociation="A_endType_association" association="A_endType_association"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedLiteral_enumeration" name="A_ownedLiteral_enumeration" memberEnd="Enumeration-ownedLiteral EnumerationLiteral-enumeration"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedAttribute_datatype" name="A_ownedAttribute_datatype" memberEnd="DataType-ownedAttribute Property-datatype"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedOperation_datatype" name="A_ownedOperation_datatype" memberEnd="DataType-ownedOperation Operation-datatype"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_raisedException_operation" name="A_raisedException_operation" memberEnd="Operation-raisedException A_raisedException_operation-operation">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_raisedException_operation-operation" name="operation" type="Operation" upper="*" lower="0" owningAssociation="A_raisedException_operation" association="A_raisedException_operation"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_redefinedOperation_operation" name="A_redefinedOperation_operation" memberEnd="Operation-redefinedOperation A_redefinedOperation_operation-operation">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinedOperation_operation-operation" name="operation" type="Operation" upper="*" lower="0" owningAssociation="A_redefinedOperation_operation" association="A_redefinedOperation_operation"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedParameter_ownerFormalParam" name="A_ownedParameter_ownerFormalParam" memberEnd="BehavioralFeature-ownedParameter A_ownedParameter_ownerFormalParam-ownerFormalParam">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedParameter_ownerFormalParam-ownerFormalParam" name="ownerFormalParam" type="BehavioralFeature" lower="0" owningAssociation="A_ownedParameter_ownerFormalParam" subsettedProperty="NamedElement-namespace" association="A_ownedParameter_ownerFormalParam"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_raisedException_behavioralFeature" name="A_raisedException_behavioralFeature" memberEnd="BehavioralFeature-raisedException A_raisedException_behavioralFeature-behavioralFeature">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_raisedException_behavioralFeature-behavioralFeature" name="behavioralFeature" type="BehavioralFeature" upper="*" lower="0" owningAssociation="A_raisedException_behavioralFeature" association="A_raisedException_behavioralFeature"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_importedMember_namespace" name="A_importedMember_namespace" memberEnd="Namespace-importedMember A_importedMember_namespace-namespace">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_importedMember_namespace-namespace" name="namespace" type="Namespace" upper="*" lower="0" owningAssociation="A_importedMember_namespace" association="A_importedMember_namespace"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_importedPackage_packageImport" name="A_importedPackage_packageImport" memberEnd="PackageImport-importedPackage A_importedPackage_packageImport-packageImport">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_importedPackage_packageImport-packageImport" name="packageImport" type="PackageImport" upper="*" lower="0" owningAssociation="A_importedPackage_packageImport" association="A_importedPackage_packageImport"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_importedElement_elementImport" name="A_importedElement_elementImport" memberEnd="ElementImport-importedElement A_importedElement_elementImport-elementImport">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_importedElement_elementImport-elementImport" name="elementImport" type="ElementImport" upper="*" lower="0" owningAssociation="A_importedElement_elementImport" association="A_importedElement_elementImport"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_elementImport_importingNamespace" name="A_elementImport_importingNamespace" memberEnd="Namespace-elementImport ElementImport-importingNamespace"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_packageImport_importingNamespace" name="A_packageImport_importingNamespace" memberEnd="Namespace-packageImport PackageImport-importingNamespace"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_packagedElement_owningPackage" name="A_packagedElement_owningPackage" memberEnd="Package-packagedElement A_packagedElement_owningPackage-owningPackage">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_packagedElement_owningPackage-owningPackage" name="owningPackage" type="Package" lower="0" owningAssociation="A_packagedElement_owningPackage" subsettedProperty="NamedElement-namespace" association="A_packagedElement_owningPackage"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedType_package" name="A_ownedType_package" memberEnd="Package-ownedType Type-package"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_memberEnd_association" name="A_memberEnd_association" memberEnd="Association-memberEnd Property-association"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_nestedPackage_nestingPackage" name="A_nestedPackage_nestingPackage" memberEnd="Package-nestedPackage Package-nestingPackage"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_type_operation" name="A_type_operation" memberEnd="Operation-type A_type_operation-operation">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_type_operation-operation" name="operation" type="Operation" upper="*" lower="0" owningAssociation="A_type_operation" association="A_type_operation"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_packageMerge_receivingPackage" name="A_packageMerge_receivingPackage" memberEnd="Package-packageMerge PackageMerge-receivingPackage"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_mergedPackage_packageMerge" name="A_mergedPackage_packageMerge" memberEnd="PackageMerge-mergedPackage A_mergedPackage_packageMerge-packageMerge">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_mergedPackage_packageMerge-packageMerge" name="packageMerge" type="PackageMerge" upper="*" lower="0" owningAssociation="A_mergedPackage_packageMerge" association="A_mergedPackage_packageMerge"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedElement_owner" name="A_ownedElement_owner" memberEnd="Element-ownedElement Element-owner"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_annotatedElement_comment" name="A_annotatedElement_comment" memberEnd="Comment-annotatedElement A_annotatedElement_comment-comment">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_annotatedElement_comment-comment" name="comment" type="Comment" upper="*" lower="0" owningAssociation="A_annotatedElement_comment" association="A_annotatedElement_comment"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_relatedElement_relationship" name="A_relatedElement_relationship" memberEnd="Relationship-relatedElement A_relatedElement_relationship-relationship">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_relatedElement_relationship-relationship" name="relationship" type="Relationship" upper="*" lower="0" owningAssociation="A_relatedElement_relationship" association="A_relatedElement_relationship"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_source_directedRelationship" name="A_source_directedRelationship" memberEnd="DirectedRelationship-source A_source_directedRelationship-directedRelationship">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_source_directedRelationship-directedRelationship" name="directedRelationship" type="DirectedRelationship" upper="*" lower="0" owningAssociation="A_source_directedRelationship" association="A_source_directedRelationship"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_target_directedRelationship" name="A_target_directedRelationship" memberEnd="DirectedRelationship-target A_target_directedRelationship-directedRelationship">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_target_directedRelationship-directedRelationship" name="directedRelationship" type="DirectedRelationship" upper="*" lower="0" owningAssociation="A_target_directedRelationship" association="A_target_directedRelationship"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_redefinitionContext_redefinableElement" name="A_redefinitionContext_redefinableElement" memberEnd="RedefinableElement-redefinitionContext A_redefinitionContext_redefinableElement-redefinableElement">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinitionContext_redefinableElement-redefinableElement" name="redefinableElement" type="RedefinableElement" upper="*" lower="0" owningAssociation="A_redefinitionContext_redefinableElement" association="A_redefinitionContext_redefinableElement"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_redefinedElement_redefinableElement" name="A_redefinedElement_redefinableElement" memberEnd="RedefinableElement-redefinedElement A_redefinedElement_redefinableElement-redefinableElement">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinedElement_redefinableElement-redefinableElement" name="redefinableElement" type="RedefinableElement" upper="*" lower="0" owningAssociation="A_redefinedElement_redefinableElement" association="A_redefinedElement_redefinableElement"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_feature_featuringClassifier" name="A_feature_featuringClassifier" memberEnd="Classifier-feature Feature-featuringClassifier"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_constrainedElement_constraint" name="A_constrainedElement_constraint" memberEnd="Constraint-constrainedElement A_constrainedElement_constraint-constraint">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_constrainedElement_constraint-constraint" name="constraint" type="Constraint" upper="*" lower="0" owningAssociation="A_constrainedElement_constraint" association="A_constrainedElement_constraint"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_specification_owningConstraint" name="A_specification_owningConstraint" memberEnd="Constraint-specification A_specification_owningConstraint-owningConstraint">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_specification_owningConstraint-owningConstraint" name="owningConstraint" type="Constraint" lower="0" owningAssociation="A_specification_owningConstraint" subsettedProperty="Element-owner" association="A_specification_owningConstraint"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_general_classifier" name="A_general_classifier" memberEnd="Classifier-general A_general_classifier-classifier">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_general_classifier-classifier" name="classifier" type="Classifier" upper="*" lower="0" owningAssociation="A_general_classifier" association="A_general_classifier"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedMember_namespace" name="A_ownedMember_namespace" memberEnd="Namespace-ownedMember NamedElement-namespace"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_member_namespace" name="A_member_namespace" memberEnd="Namespace-member A_member_namespace-namespace">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_member_namespace-namespace" name="namespace" type="Namespace" upper="*" lower="0" owningAssociation="A_member_namespace" association="A_member_namespace"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_operand_expression" name="A_operand_expression" memberEnd="Expression-operand A_operand_expression-expression">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_operand_expression-expression" name="expression" type="Expression" lower="0" owningAssociation="A_operand_expression" subsettedProperty="Element-owner" association="A_operand_expression"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_navigableOwnedEnd_association" name="A_navigableOwnedEnd_association" memberEnd="Association-navigableOwnedEnd A_navigableOwnedEnd_association-association">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_navigableOwnedEnd_association-association" name="association" type="Association" lower="0" owningAssociation="A_navigableOwnedEnd_association" association="A_navigableOwnedEnd_association"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedParameter_operation" name="A_ownedParameter_operation" memberEnd="Operation-ownedParameter Parameter-operation"/>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedComment_owningElement" name="A_ownedComment_owningElement" memberEnd="Element-ownedComment A_ownedComment_owningElement-owningElement">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedComment_owningElement-owningElement" name="owningElement" type="Element" lower="0" owningAssociation="A_ownedComment_owningElement" subsettedProperty="Element-owner" association="A_ownedComment_owningElement"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_inheritedMember_classifier" name="A_inheritedMember_classifier" memberEnd="Classifier-inheritedMember A_inheritedMember_classifier-classifier">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_inheritedMember_classifier-classifier" name="classifier" type="Classifier" upper="*" lower="0" owningAssociation="A_inheritedMember_classifier" association="A_inheritedMember_classifier"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_precondition_preContext" name="A_precondition_preContext" memberEnd="Operation-precondition A_precondition_preContext-preContext">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_precondition_preContext-preContext" name="preContext" type="Operation" lower="0" owningAssociation="A_precondition_preContext" subsettedProperty="Constraint-context" association="A_precondition_preContext"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_postcondition_postContext" name="A_postcondition_postContext" memberEnd="Operation-postcondition A_postcondition_postContext-postContext">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_postcondition_postContext-postContext" name="postContext" type="Operation" lower="0" owningAssociation="A_postcondition_postContext" subsettedProperty="Constraint-context" association="A_postcondition_postContext"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_bodyCondition_bodyContext" name="A_bodyCondition_bodyContext" memberEnd="Operation-bodyCondition A_bodyCondition_bodyContext-bodyContext">
      <ownedEnd xmi:type="cmof:Property" xmi:id="A_bodyCondition_bodyContext-bodyContext" name="bodyContext" type="Operation" lower="0" owningAssociation="A_bodyCondition_bodyContext" subsettedProperty="Constraint-context" association="A_bodyCondition_bodyContext"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="A_ownedRule_context" name="A_ownedRule_context" memberEnd="Namespace-ownedRule Constraint-context"/>
    <packagedElement xmi:type="cmof:Class" xmi:id="Tag" name="Tag">
      <!--  XXX CMOF 2.4: Tag is not inherited from Element now.
      <generalization xmi:type="uml:Generalization" xmi:id="_MOF-Extension-Tag-Generalization.0">
        <general xmi:idref="_MOF-Reflection-Element"/>
      </generalization>
      -->
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Tag-name" name="name" type="String"/>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Tag-value" name="value" type="String"/>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Tag-element" name="element" type="Element" lower="0" upper="*" association="_MOF-Extension-A_element_tag"/>
      <ownedAttribute xmi:type="cmof:Property" xmi:id="Tag-tagOwner" name="tagOwner" type="Element" lower="0" subsettedProperty="Element-owner" association="_MOF-CMOFExtension-A_ownedTag_tagOwner"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="_MOF-Extension-A_element_tag" name="A_element_tag" memberEnd="Tag-element _MOF-Extension-A_element_tag-tag">
      <ownedEnd xmi:type="cmof:Property" xmi:id="_MOF-Extension-A_element_tag-tag" name="tag" type="Tag" association="_MOF-Extension-A_element_tag"/>
    </packagedElement>
    <packagedElement xmi:type="cmof:Association" xmi:id="_MOF-CMOFExtension-A_ownedTag_tagOwner" name="A_ownedTag_tagOwner" memberEnd="A_ownedTag_tagOwner-ownedTag Tag-tagOwner">
       <ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedTag_tagOwner-ownedTag" name="ownedTag" type="Tag" isComposite="true" lower="0" upper="*" subsettedProperty="Element-ownedElement" association="_MOF-CMOFExtension-A_ownedTag_tagOwner"/>
    </packagedElement>
  </cmof:Package>
  <cmof:Tag xmi:id="_3" name="org.omg.xmi.nsPrefix" value="cmof" element="_0"/>
  <cmof:Tag xmi:id="_4" name="org.omg.xmi.nsURI" value="http://schema.omg.org/spec/MOF/2.0/cmof.xml" element="_0"/>
</xmi:XMI>
